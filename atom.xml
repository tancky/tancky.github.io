<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tancky&#39;s  Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tancky.github.io/"/>
  <updated>2018-01-03T13:23:02.640Z</updated>
  <id>https://tancky.github.io/</id>
  
  <author>
    <name>Tancky</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2017年终总结</title>
    <link href="https://tancky.github.io/2018/01/03/2017%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://tancky.github.io/2018/01/03/2017年终总结/</id>
    <published>2018-01-03T13:22:04.036Z</published>
    <updated>2018-01-03T13:23:02.640Z</updated>
    
    <content type="html"><![CDATA[<pre><code>今天是2018年1月3日，人生中第一次写年终总结，想想还有点小激动呢。虽然这篇文章有点姗姗来迟。&lt;!--more--&gt;
</code></pre><p>  感谢我的2017。让我顺利的进入了前端的世界，成为一名前端开发人员。事实上，我一直不敢称自己为前端开发工程师。因为与我而言，仅仅是在前端的道路上行进了一小步。雷军曾说过: ‘就是要做一头站在风口上的猪,风口站对了,猪也可以飞起来’。随着互联网，移动互联网的浪潮，‘前端工程师’这个新兴的工作岗位受到了极高的关注。自然而然的吸引了一大批的从业者，不管他们来自哪所大学亦或是那个培训机构。而我，自然而然也是其中的一员，作为非科班出身的专科毕业生，我坚定地相信：选择永远比努力更重要。所以，我花了整整一年的时间自学才毅然的闯进了前端的大门。这一年，我没有去培训机构，在小小的出租屋里面买了一堆以前自己闻所未闻的书籍，还差一点跟自己最心爱的女朋友分手，个中滋味只有自己能懂。</p>
<h3 id="承蒙时光不弃-感谢一切给予"><a href="#承蒙时光不弃-感谢一切给予" class="headerlink" title="承蒙时光不弃 感谢一切给予"></a>承蒙时光不弃 感谢一切给予</h3><p>2017年我找到了一份向往的工作，感谢面试我的同事，能够给予我这个机会。让我从一个小小菜鸟晋升到了小菜鸟。整整一年，最大的体会就是前端的知识体系过于庞大，过于零散。很多层出不穷的框架，让人眼花缭乱。亲眼看见了jQuery时代的落幕，React、Vue、Augular的兴起。操作dom的时代已然过去，数据驱动视图的新兴思想将会主导未来的前端领域。ES6的全面普及，将javascirpt这门基于原型的语言变得越来越oop化。前后端分离的思想也越来越主流，Webpack一起绝尘，年末又出来一个Parcel，2018年又会擦出怎样的火花。移动端h5微场景已然成为营销推广的利器，小程序也慢慢崛起，React-Native给了前端工作者想‘一统三端’的伟大梦想…</p>
<p>框架虽多，但万变不离其宗。我一直谨记前辈时刻强调，在前端目前这个浮躁的环境下，学好基础，什么框架来了都不怕。2017年，我夯实了自己的css基础，页面布局更加迅速，有效率，感谢我的公司不考虑万恶的IE。让我可以从容的毫无顾忌的使用flex进行页面布局，grid布局现在也提上了日程，将来一定会成为主流（虽然我还没有学，毕竟兼容性太差），导致我现在似乎已经忘了怎么使用float，这个曾经让我又爱又恨的属性。感谢JavaScirpt一遍又一遍的虐我，让我一遍又一遍的长记性，让我理解了什么是原型，原型链，什么是闭包，作用域。这些知识虽然平常工作中很少用到，但是，想要更好的晋升，理解语言的精髓才是最重要的。相较于webpack繁琐的配置项，我更喜欢gulp的‘管道流’思想，更直观，更好写。而2018年我看好Parcel所谓的‘0配置打包’。<br>2017年，由于公司项目需要开发微信小程序，我总共参与了3个微信小程序的项目开发，总的来说就是写的挺爽，小程序完全借鉴了Vue、React的思想，拒绝操作DOM，用数据驱动视图的思想进行UI层的渲染，当数据改变时，重新渲染UI界面。组件化的开发思想，代码的高复用性，原生APP的用户体验，都深深的影响了我。直到今日，小程序已经开放了诸多的权限，包括小游戏。2018年小程序必然是会爆发的一年。2017年我也自己写了一个Vue的实战项目，仿ACfun弹幕视频网的Webapp，旨在通过动手更好的学习这个由国人编写并维护的前端框架。Talk is cheap，show me the code。当然还有类似公众号开发，h5微场景营销专题页面的开发，企业站等等公司项目就不再赘述，总之这一年收获非常多，但是付出也是值得的。2017年我买了3本书，《JavaScript语言精粹》《CSS世界》《深入浅出React和Redux》，也学习了很多对我来说获益匪浅的知识。</p>
<p>展望2018，希望自己能在前端这条道路上越走越远，越走越踏实。更加热爱编程，提高自己的编程意识和组件化思想，继续夯实JS基础，学好React，写一套自己开发的组件库，最大的愿望就是用React-Native开发一款真正的原生APP。深入学习NodeJS和MongoDB，向全栈进发，最后也希望可以和我心爱的女朋友一直走下去，走进婚姻的殿堂，2018你好！2017再见！</p>
]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;今天是2018年1月3日，人生中第一次写年终总结，想想还有点小激动呢。虽然这篇文章有点姗姗来迟。&amp;lt;!--more--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  感谢我的2017。让我顺利的进入了前端的世界，成为一名前端开发人员。事实上，我一直不敢称自
    
    </summary>
    
      <category term="Fe" scheme="https://tancky.github.io/categories/Fe/"/>
    
    
      <category term="Fe" scheme="https://tancky.github.io/tags/Fe/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序踩坑心得（一）电商倒计时效果实现</title>
    <link href="https://tancky.github.io/2017/10/30/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B8%A9%E5%9D%91%E5%BF%83%E5%BE%97%EF%BC%88%E4%B8%80%EF%BC%89%E7%94%B5%E5%95%86%E5%80%92%E8%AE%A1%E6%97%B6%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/"/>
    <id>https://tancky.github.io/2017/10/30/微信小程序踩坑心得（一）电商倒计时效果实现/</id>
    <published>2017-10-30T15:06:17.718Z</published>
    <updated>2017-10-30T15:10:35.989Z</updated>
    
    <content type="html"><![CDATA[<p>标签： xcx</p>
<hr>
<p>2017年1月9号，张小龙微信团队正式发布了微信小程序，直到现在已经过去了大半年时间了。用户广度和深度方面看起来和预期还是有点差距，但是这并不妨碍作为一个前端开发者的我对他浓厚的极其浓厚的兴趣。我曾经也很想自己开发一款app，如今小程序帮我做到了。最近着手了一个家具商城的小程序项目，特地分享一下自己的踩坑心得<a id="more"></a>，小程序的前景怎么样我不知道，我只知道动手就干！！！。</p>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>小程序跟各主流前端开发框架的理念一样（Vue，React，Angular），核心都是以数据驱动视图，抛弃了以前传统的前端开发，JQuery在手，天下我有的局面。在小程序中并不能直接的操作dom元素，所以用惯了JQ，zepto等js库的童鞋剁手吧。</p>
<p>下面先来看一下倒计时的实现效果吧</p>
<p><img src="http://oyn3t7b0h.bkt.clouddn.com/17-10-30/50597200.jpg" alt="倒计时效果"></p>
<p>码代码前先把思路理清楚！！！码代码前先把思路理清楚！！！码代码前先把思路理清楚！！！</p>
<p>重要的事情说三遍！！！</p>
<p>1.从后端接口获取结束时间时的时间戳，我在项目中得到的是字段end_time</p>
<p>2.通过JS调用原生的date方法获取当前的时间戳，</p>
<p>3.用end_time 减去当前的时间戳，获得所有剩余的时间戳</p>
<p>4.封装一个函数用来将时间戳转化为时间点，以天/时/分/秒返回。</p>
<p>5.!!核心的一段代码，调用setimeout/setimeInterval()方法，每隔1秒循环递归调用方法，并改写数据that.setData({})，最终实现倒计时。</p>
<p>在多嘴一句，私以为写代码之前都要养成一个良好的习惯，就是先理清楚业务逻辑，最好可以以脑图的方式展现出来，这样不仅可以锻炼自己的逻辑思维能力，还可以提高自己的软实力，从而提高开发效率。</p>
<p>1.首先通过wx.request()API方法从后端请求数据接口</p>
<p><img src="http://oyn3t7b0h.bkt.clouddn.com/17-10-30/50039104.jpg" alt="请求接口数据"></p>
<p>2.将endTime变量存入data中，以便全局调用</p>
<p><img src="http://oyn3t7b0h.bkt.clouddn.com/17-10-30/51145774.jpg" alt="请求接口数据"></p>
<p>3.封装格式化日期函数，并返回拼接的日期字符串</p>
<p><img src="http://oyn3t7b0h.bkt.clouddn.com/17-10-30/54901373.jpg" alt="请求接口数据"></p>
<p>4.倒计时逻辑</p>
<p><img src="http://oyn3t7b0h.bkt.clouddn.com/17-10-30/21813676.jpg" alt="倒计时逻辑"></p>
<p>5.最后在生命周期onload函数中调用请求数据this.getlist()方法,并在请求成功返回后，调用coundDown函数实现倒计时！</p>
<p><img src="http://oyn3t7b0h.bkt.clouddn.com/17-10-30/18027799.jpg" alt="倒计时逻辑"></p>
<p>以上</p>
<h2 id="写在结尾"><a href="#写在结尾" class="headerlink" title="写在结尾"></a>写在结尾</h2><p>这是我进行开发的第二个项目，也是第一个电商类型的小程序项目，其中有很多的坑需要一步步的踩，由于项目周期非常的紧迫，所以只有抽出空来记录下自己的学习经验。在前端工程化愈演愈烈的今天，学习新技术是必不可少的，只有紧跟时代才不会被时代所淘汰。前端框架虽多，但其实万变不离其宗，只要深入理解了其中的设计思想，剩下的就仅仅是看api了。前端之路任重而道远，且行且珍惜。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;标签： xcx&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;2017年1月9号，张小龙微信团队正式发布了微信小程序，直到现在已经过去了大半年时间了。用户广度和深度方面看起来和预期还是有点差距，但是这并不妨碍作为一个前端开发者的我对他浓厚的极其浓厚的兴趣。我曾经也很想自己开发一款app，如今小程序帮我做到了。最近着手了一个家具商城的小程序项目，特地分享一下自己的踩坑心得
    
    </summary>
    
      <category term="xcx" scheme="https://tancky.github.io/categories/xcx/"/>
    
    
      <category term="xcx" scheme="https://tancky.github.io/tags/xcx/"/>
    
  </entry>
  
  <entry>
    <title>vue项目打包上线流程</title>
    <link href="https://tancky.github.io/2017/07/13/vue%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%B8%8A%E7%BA%BF%E6%B5%81%E7%A8%8B/"/>
    <id>https://tancky.github.io/2017/07/13/vue项目打包上线流程/</id>
    <published>2017-07-13T15:31:06.323Z</published>
    <updated>2017-07-13T15:34:36.886Z</updated>
    
    <content type="html"><![CDATA[<p> 自己写的Vue项目终于大致完成了，由于没有买域名和服务器，但是项目要上线。思来想去发现github上可以直接用创建个人项目的上线演示，这给我带来了极大的便利，在维护源码的同时还能生成项目主页可供在线预览。简直美滋滋。<a id="more"></a>但是由于第一次用这玩意儿，花费了我整整一天的时间，期间出现了各种问题，但俗话说得好：功夫不负有心人，终于在晚上把他给上线了，哈哈哈。</p>
<p>Github给用户提供了运行静态页面的地址，如何展示个人项目的静态页面？以下是创建项目主页的关键：</p>
<blockquote>
<p>gh-pages分支</p>
<p>访问地址：[github用户名].github.io/[项目仓库名]，如：tancky5.github.io/vue-acfun（不要脸的把自己的项目贴了上来哈哈）</p>
</blockquote>
<p>生成项目主页首先是将想要展示的静态页面推送的Github个人项目仓库的gh-pages分支下，然后通过上述的访问形式访问。</p>
<p>至于如何使用git提交到github上这里我就直接忽略了，有兴趣的可以自己去网上看教程，一找一大堆。</p>
<p>由于我是使用vue-cli脚手架搭建的项目，所以代码压缩打包只需要npm run build一样就可以了，接下来才是关键!!!</p>
<p>第一步： 在github上点击你的项目进去之后点击settings</p>
<p><img src="http://i4.piimg.com/1949/931e3f36070f9f95.png" alt="项目"></p>
<p>第二步： 找到github-pages 切换到gh-pages分支，然后点击save(保存),就会生成如图所示的链接，这个链接就是你的项目预览地址</p>
<p><img src="http://i4.piimg.com/1949/74e5832ad5fdc34e.png" alt="项目"></p>
<p>第三步：在主分支master下run build打包代码（一定要先在master分支下build）,然后切换到gh-pages分支 </p>
<ol>
<li>git checkout -b gh-pages</li>
</ol>
<ol>
<li><p>在gh-pages再次执行 npm run build命令</p>
</li>
<li><p>将dist目录下的所有文件夹推送至远程仓库的gh-pages分支，执行以下命令：</p>
</li>
</ol>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//强制添加dist文件夹，因为.gitignore文件中定义了忽略该文件</span></div><div class="line">git <span class="built_in">add</span> -f <span class="built_in">dist</span></div><div class="line"></div><div class="line"><span class="comment">//提交到本地暂存区</span></div><div class="line">git commit -m <span class="string">'Initial the page of project'</span></div><div class="line"></div><div class="line"><span class="comment">//部署dist目录下的代码</span></div><div class="line">git subtree push --prefix <span class="built_in">dist</span> origin gh-pages</div></pre></td></tr></table></figure>
<p>此时打开刚才的链接就可以浏览自己的项目了，当然需要等那么一小会儿，毕竟页面需要加载时间。</p>
<p>虽然看着上面的流程很简单，其实真正自己上线的时候一个不小心就会有一堆错误，尤其是要先在master分支下build一次，然后切换到gh-pages分支下再build一次,否则的话，自己去试试就知道了，这是个深坑，多么痛的领悟！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 自己写的Vue项目终于大致完成了，由于没有买域名和服务器，但是项目要上线。思来想去发现github上可以直接用创建个人项目的上线演示，这给我带来了极大的便利，在维护源码的同时还能生成项目主页可供在线预览。简直美滋滋。
    
    </summary>
    
      <category term="JavaScript" scheme="https://tancky.github.io/categories/JavaScript/"/>
    
    
      <category term="Vue.js" scheme="https://tancky.github.io/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>vue-cli上线打包出现的图片路径解析问题</title>
    <link href="https://tancky.github.io/2017/07/13/vue-cli%E4%B8%8A%E7%BA%BF%E6%89%93%E5%8C%85%E5%87%BA%E7%8E%B0%E7%9A%84%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%9E%90%E9%97%AE%E9%A2%98/"/>
    <id>https://tancky.github.io/2017/07/13/vue-cli上线打包出现的图片路径解析问题/</id>
    <published>2017-07-13T04:44:50.453Z</published>
    <updated>2017-07-13T04:45:44.829Z</updated>
    
    <content type="html"><![CDATA[<p>自己写的移动端项目（仿Acfun弹幕视频网）基本上已经搞定了，可是在npm run build打包上线时却出现了问题，关于图片资源路径解析的问题<a id="more"></a>，在网上查了很久，终于找到了解决方案。</p>
<p>由于用的是vue-cli脚手架搭建的项目，所以图片默认的存放地址是src/assets/img下。</p>
<p><img src="http://chuantu.biz/t5/133/1499920370x2071187492.png" alt="地址信息"></p>
<p>在开发过程中，大部分情况下都是用img标签来引用图片资源，like this：</p>
<p><img src="http://chuantu.biz/t5/133/1499920513x2728328999.png" alt="地址信息"></p>
<p>or this:</p>
<p><img src="http://chuantu.biz/t5/133/1499920622x2728328999.png" alt="地址信息"></p>
<p>如果所有的图片资源都是用img标签来引用的话，vue-cli在上线打包的时候路径解析不会出现问题亲测。但是如果用css的background-img来引用图片资源的话打包时候就会报错！！！ like this：</p>
<p><img src="http://chuantu.biz/t5/133/1499920778x2728328999.png" alt="地址信息"></p>
<p>解决方案来了（来自stackoverflow）：</p>
<p><img src="https://sfault-image.b0.upaiyun.com/218/085/218085424-5941fbc5785d3" alt="地址信息"></p>
<p>划重点：</p>
<p>1.在 config/index.js 中修改 assetsPublicPath 为 ./ （上线打包时需要更改的目录路径）</p>
<p>2.在 build/utils.js 中的 ExtractTextPlugin.extract 传入参数 publicPath: ‘../../‘</p>
<p>只需以上两步，就能完美解决本地和服务器上资源url解析的问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己写的移动端项目（仿Acfun弹幕视频网）基本上已经搞定了，可是在npm run build打包上线时却出现了问题，关于图片资源路径解析的问题
    
    </summary>
    
      <category term="JavaScript" scheme="https://tancky.github.io/categories/JavaScript/"/>
    
    
      <category term="Vue.js" scheme="https://tancky.github.io/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>关于对Vue生命周期的理解</title>
    <link href="https://tancky.github.io/2017/07/09/%E5%85%B3%E4%BA%8E%E5%AF%B9Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://tancky.github.io/2017/07/09/关于对Vue生命周期的理解/</id>
    <published>2017-07-09T15:03:30.056Z</published>
    <updated>2017-07-09T15:06:32.033Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>最近一直在写一个Vue的单页SPA移动端项目，虽然遇到了很多问题，踩了不少的坑，但同时对Vue的学习与理解也更加深入了。在做项目的时候经常会分不清 created,mounted等钩子函数的用法，不知道应该何时运用，怎么运用。实际上只要搞懂了Vue的生命周期，就能‘运筹帷幄之中，决胜于千里之外了’。今天来谈一谈有关Vue生命周期的理解。<a id="more"></a>（以最新的Vue2.0为基础）</p>
<blockquote>
<p>Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、卸载等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。</p>
</blockquote>
<p>官方的图示</p>
<p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="Vue生命周期"></p>
<p>我最开始看这个图的时候也是一脸懵逼，不过没关系。通俗地来说，可以理解为人的一生从出生到死亡分别经历的不同阶段（胎儿，婴儿，少年，青年，中年，老年等），而这些阶段就是所谓的‘钩子’，利用这些钩子（即钩子函数）可以注册一些需要的方法，从而达到控制整个过程的目的。</p>
<p>结合代码来看一下</p>
<figure class="highlight django"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE html&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/vue/2.1.3/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="template-variable">&#123;&#123; message &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">    </div><div class="line">  <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</div><div class="line">      <span class="attr">el</span>: <span class="string">'#app'</span>,</div><div class="line">      <span class="attr">data</span>: &#123;</div><div class="line">          <span class="attr">message</span> : <span class="string">"xuxiao is boy"</span> </div><div class="line">      &#125;,</div><div class="line">       <span class="attr">beforeCreate</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.group(<span class="string">'beforeCreate 创建前状态===============》'</span>);</div><div class="line">               <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span> , <span class="string">"el     : "</span> + <span class="keyword">this</span>.$el); <span class="comment">//undefined</span></div><div class="line">               <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + <span class="keyword">this</span>.$data); <span class="comment">//undefined </span></div><div class="line">               <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + <span class="keyword">this</span>.message)  </div><div class="line">        &#125;,</div><div class="line">        <span class="attr">created</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.group(<span class="string">'created 创建完毕状态===============》'</span>);</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"el     : "</span> + <span class="keyword">this</span>.$el); <span class="comment">//undefined</span></div><div class="line">               <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + <span class="keyword">this</span>.$data); <span class="comment">//已被初始化 </span></div><div class="line">               <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + <span class="keyword">this</span>.message); <span class="comment">//已被初始化</span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">beforeMount</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.group(<span class="string">'beforeMount 挂载前状态===============》'</span>);</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"el     : "</span> + (<span class="keyword">this</span>.$el)); <span class="comment">//已被初始化</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</div><div class="line">               <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + <span class="keyword">this</span>.$data); <span class="comment">//已被初始化  </span></div><div class="line">               <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + <span class="keyword">this</span>.message); <span class="comment">//已被初始化  </span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">mounted</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.group(<span class="string">'mounted 挂载结束状态===============》'</span>);</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"el     : "</span> + <span class="keyword">this</span>.$el); <span class="comment">//已被初始化</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);    </div><div class="line">               <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + <span class="keyword">this</span>.$data); <span class="comment">//已被初始化</span></div><div class="line">               <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + <span class="keyword">this</span>.message); <span class="comment">//已被初始化 </span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">beforeUpdate</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.group(<span class="string">'beforeUpdate 更新前状态===============》'</span>);</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"el     : "</span> + <span class="keyword">this</span>.$el);</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);   </div><div class="line">               <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + <span class="keyword">this</span>.$data); </div><div class="line">               <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + <span class="keyword">this</span>.message); </div><div class="line">        &#125;,</div><div class="line">        <span class="attr">updated</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.group(<span class="string">'updated 更新完成状态===============》'</span>);</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"el     : "</span> + <span class="keyword">this</span>.$el);</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el); </div><div class="line">               <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + <span class="keyword">this</span>.$data); </div><div class="line">               <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + <span class="keyword">this</span>.message); </div><div class="line">        &#125;,</div><div class="line">        <span class="attr">beforeDestroy</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.group(<span class="string">'beforeDestroy 销毁前状态===============》'</span>);</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"el     : "</span> + <span class="keyword">this</span>.$el);</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);    </div><div class="line">               <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + <span class="keyword">this</span>.$data); </div><div class="line">               <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + <span class="keyword">this</span>.message); </div><div class="line">        &#125;,</div><div class="line">        <span class="attr">destroyed</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.group(<span class="string">'destroyed 销毁完成状态===============》'</span>);</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"el     : "</span> + <span class="keyword">this</span>.$el);</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);  </div><div class="line">               <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + <span class="keyword">this</span>.$data); </div><div class="line">               <span class="built_in">console</span>.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + <span class="keyword">this</span>.message)</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p><img src="https://sfault-image.b0.upaiyun.com/130/248/1302481017-586cddaf83195" alt="组件创建之前状态"></p>
<h2 id="一-beforeCreate"><a href="#一-beforeCreate" class="headerlink" title="一.beforeCreate"></a>一.beforeCreate</h2><p>console.log(this.\$data), undefined，说明：<br>组件实例被创建，组件属性计算之前，如data属性等</p>
<p>应用：可以在这加个loading事件 </p>
<h2 id="二-created"><a href="#二-created" class="headerlink" title="二.created"></a>二.created</h2><p>注意触发vue的created事件以后,this便指向vue实例(划重点！！！)<br>console.log(this.\$data),已经将data数据打印出来，说明：</p>
<p>1.组件实例创建完成，属性已经绑定，但DOM还未生成，\$el属性还不存在<br>2.在实例创建之后同步调用。此时实例已经结束解析选项，这意味着已建立：数据绑定，计算属性，方法，watcher/事件回调。<br>3.但是还没有开始 DOM 编译，$el 还不存在,但是实例存在,即this.\$data存在,可打印出来 。</p>
<p>应用：在这结束loading，还做一些初始化，实现函数自执行 </p>
<h2 id="三-beforeMount"><a href="#三-beforeMount" class="headerlink" title="三.beforeMount"></a>三.beforeMount</h2><p>在模板编译，挂载开始之前被调用,在标红处，我们能发现el还是 ，这里就是应用的 Virtual DOM（虚拟Dom）技术，先把坑占住了。到后面mounted挂载的时候再把值渲染进去。</p>
<h2 id="四-mounted"><a href="#四-mounted" class="headerlink" title="四.mounted"></a>四.mounted</h2><p>1.模板编译、挂载之后不保证组件已在document中<br>2.在编译结束后调用。此时所有的指令已生效，因而数据的变化将触发 DOM 更新。但是不担保 $el 已插入文档。</p>
<p>应用：mounted阶段做ajax，或者配合路由钩子做一些事情;此时DOM已经获取到，可以对DOM进行操作。</p>
<h2 id="五-beforeUpdate"><a href="#五-beforeUpdate" class="headerlink" title="五.beforeUpdate"></a>五.beforeUpdate</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.message= <span class="symbol">'yes</span> !! I <span class="keyword">do</span>';</div></pre></td></tr></table></figure>
<p><img src="https://sfault-image.b0.upaiyun.com/970/506/970506402-586cdf5fb1fe1" alt="组件更新状态"></p>
<p>1.数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。<br>2.你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。<br>3.该钩子在服务器端渲染期间不被调用。</p>
<h2 id="六-updated"><a href="#六-updated" class="headerlink" title="六.updated"></a>六.updated</h2><p>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。<br>然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。</p>
<h2 id="七-beforeDestroy"><a href="#七-beforeDestroy" class="headerlink" title="七.beforeDestroy"></a>七.beforeDestroy</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">app</span>.<span class="variable">$destroy</span>();</div></pre></td></tr></table></figure>
<p><img src="https://sfault-image.b0.upaiyun.com/396/155/3961550519-586ce0cb13de2" alt="组件销毁状态"></p>
<p>1.组件销毁前触发<br>2.触发方式,在console里面打myVue.$destroy();<br>3.在开始销毁实例时调用。此时实例仍然有功能。</p>
<p>应用：beforeDestory 你确认删除XX吗？</p>
<h2 id="八-destroyed"><a href="#八-destroyed" class="headerlink" title="八.destroyed"></a>八.destroyed</h2><p>1.触发方式,在console里面打myVue.$destroy();其中myVue.\$destroy(true)是删除DOM节点,会触发detached函数,但是实例仍然存在<br>2.在实例被销毁之后调用。此时所有的绑定和实例的指令已经解绑，注意是解绑不是销毁,所有的子实例也已经被销毁。<br>应用：destoryed当前组件已被删除，清空相关内容</p>
<p>有关于销毁，暂时还不是很清楚。我们在console里执行下命令对 vue实例进行销毁。销毁完成后，我们再重新改变message的值，vue不再对此动作进行响应了。但是原先生成的dom元素还存在，可以这么理解，执行了destroy操作，后续就不再受vue控制了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;最近一直在写一个Vue的单页SPA移动端项目，虽然遇到了很多问题，踩了不少的坑，但同时对Vue的学习与理解也更加深入了。在做项目的时候经常会分不清 created,mounted等钩子函数的用法，不知道应该何时运用，怎么运用。实际上只要搞懂了Vue的生命周期，就能‘运筹帷幄之中，决胜于千里之外了’。今天来谈一谈有关Vue生命周期的理解。
    
    </summary>
    
      <category term="JavaScript" scheme="https://tancky.github.io/categories/JavaScript/"/>
    
    
      <category term="Vue.js" scheme="https://tancky.github.io/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>Vue-cli#2.0项目结构分析</title>
    <link href="https://tancky.github.io/2017/06/26/Vue-cli-2-0%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
    <id>https://tancky.github.io/2017/06/26/Vue-cli-2-0项目结构分析/</id>
    <published>2017-06-26T14:41:30.281Z</published>
    <updated>2017-06-26T15:09:25.939Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习Vue.js框架，正打算做一个小项目练练手。第一步当然少不了强大的Vue-cli脚手架工具。那么什么是Vue-cli呢？<a id="more"></a></p>
<blockquote>
<p>Vue-cli是vue官方出品的快速构建单页应用的脚手架，他可以快速的帮你构建一个强大的Vue.js项目。</p>
</blockquote>
<h2 id="一-安装Vue-cli"><a href="#一-安装Vue-cli" class="headerlink" title="一.  安装Vue-cli"></a>一.  安装Vue-cli</h2><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install vue-<span class="keyword">cli</span> -g</div></pre></td></tr></table></figure>
<p>-g :代表全局安装。如果你安装时报错，一般是网络问题，你可以尝试用cnpm来进行安装。安装完成后，可以用vue -V来进行查看 vue-cli的版本号。注意这里的V是大写的。我这里版本号是2.8.1.</p>
<p>如果vue -V的命令管用了，说明已经顺利的把vue-cli安装到我们的计算机里了。</p>
<h2 id="二-初始化项目"><a href="#二-初始化项目" class="headerlink" title="二. 初始化项目"></a>二. 初始化项目</h2><p>我们用vue init命令来初始化项目，具体看一下这条命令的使用方法。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vue init &lt;template-<span class="built_in">name</span>&gt; &lt;project-<span class="built_in">name</span>&gt;</div></pre></td></tr></table></figure>
<p>init：表示我要用vue-cli来初始化项目</p>
<p>template-name：表示模板名称，vue-cli官方为我们提供了5种模板，</p>
<p>webpack-一个全面的webpack+vue-loader的模板，功能包括热加载，linting,检测和CSS扩展。</p>
<p>webpack-simple-一个简单webpack+vue-loader的模板，不包含其他功能，让你快速的搭建vue的开发环境。</p>
<p>browserify-一个全面的Browserify+vueify 的模板，功能包括热加载，linting,单元检测。</p>
<p>browserify-simple-一个简单Browserify+vueify的模板，不包含其他功能，让你快速的搭建vue的开发环境。</p>
<p>simple-一个最简单的单页应用模板。</p>
<p>project-name：标识项目名称，这个你可以根据自己的项目来起名字。</p>
<p>在实际开发中，一般我们都会使用webpack这个模板，那我们这里也安装这个模板，在命令行输入以下命令：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">vue init webpack vuecliTest</span></div></pre></td></tr></table></figure>
<p>输入命令后，会询问我们几个简单的选项，我们根据自己的需要进行填写就可以了。</p>
<p>Project name :项目名称 ，如果不需要更改直接回车就可以了。注意：这里不能使用大写，所以我把名称改成了vueclitest</p>
<p>Project description:项目描述，默认为A Vue.js project,直接回车，不用编写。</p>
<p>Author：作者，如果你有配置git的作者，他会读取。</p>
<p>Install  vue-router? 是否安装vue的路由插件，我们这里需要安装，所以选择Y</p>
<p>Use ESLint to lint your code?</p>
<p>是否用ESLint来限制你的代码错误和风格。我们这里不需要输入n，如果你是大型团队开发，最好是进行配置。<br>setup unit tests with  Karma + Mocha?</p>
<p>是否需要安装单元测试工具Karma+Mocha，我们这里不需要，所以输入n。</p>
<p>Setup e2e tests with Nightwatch?是否安装e2e来进行用户行为模拟测试，我们这里不需要，所以输入n。<br>命令行出现上面的文字，说明我们已经初始化好了第一步。命令行提示我们现在可以作的三件事情。</p>
<p>1、cd vuecliTest  进入我们的vue项目目录。</p>
<p>2、npm install  安装我们的项目依赖包，也就是安装package.json里的包，如果你网速不好，你也可以使用cnpm来安装。</p>
<p>3、npm run dev 开发模式下运行我们的程序。给我们自动构建了开发用的服务器环境和在浏览器中打开，并实时监视我们的代码更改，即时呈现给我们。</p>
<h2 id="三-Vue-cli项目结构分析"><a href="#三-Vue-cli项目结构分析" class="headerlink" title="三.Vue-cli项目结构分析"></a>三.Vue-cli项目结构分析</h2><p>vue-cli脚手架工具就是为我们搭建了开发所需要的环境，为我们省去了很多精力。有必要对这个环境进行熟悉，我们就从项目的结构讲起。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">|-- build                            // 项目构建(webpack)相关代码</div><div class="line">|   |-- build.js                     // 生产环境构建代码</div><div class="line">|   |-- check-version.js             // 检查node、npm等版本</div><div class="line">|   |-- dev-client.js                // 热重载相关</div><div class="line">|   |-- dev-server.js                // 构建本地服务器</div><div class="line">|   |-- utils.js                     // 构建工具相关</div><div class="line">|   |-- webpack.base.conf.js         // webpack基础配置</div><div class="line">|   |-- webpack.dev.conf.js          // webpack开发环境配置</div><div class="line">|   |-- webpack.prod.conf.js         // webpack生产环境配置</div><div class="line">|-- config                           // 项目开发环境配置</div><div class="line">|   |-- dev.env.js                   // 开发环境变量</div><div class="line">|   |-- index.js                     // 项目一些配置变量</div><div class="line">|   |-- prod.env.js                  // 生产环境变量</div><div class="line">|   |-- test.env.js                  // 测试环境变量</div><div class="line">|-- src                              // 源码目录</div><div class="line">|   |-- components                     // vue公共组件</div><div class="line">|   |-- store                          // vuex的状态管理</div><div class="line">|   |-- App.vue                        // 页面入口文件</div><div class="line">|   |-- main.js                        // 程序入口文件，加载各种公共组件</div><div class="line">|-- static                           // 静态文件，比如一些图片，json数据等</div><div class="line">|   |-- data                           // 群聊分析得到的数据用于数据可视化</div><div class="line">|-- .babelrc                         // ES6语法编译配置</div><div class="line">|-- .editorconfig                    // 定义代码格式</div><div class="line">|-- .gitignore                       // git上传需要忽略的文件格式</div><div class="line">|-- README.md                        // 项目说明</div><div class="line">|-- favicon.ico </div><div class="line">|-- index.html                       // 入口页面</div><div class="line">|-- package.json                     // 项目基本信息</div><div class="line">.</div></pre></td></tr></table></figure>
<h3 id="1-Package-json"><a href="#1-Package-json" class="headerlink" title="1.Package.json"></a>1.Package.json</h3><p>package.json文件是项目根目录下的一个文件，定义该项目开发所需要的各种模块以及一些项目配置信息（如项目名称、版本、描述、作者等）。</p>
<p>package.json 里的scripts字段，这个字段定义了你可以用npm运行的命令。在开发环境下，在命令行工具中运行npm run dev 就相当于执行 node build/dev-server.js  .也就是开启了一个node写的开发行建议服务器。由此可以看出script字段是用来指定npm相关命令的缩写。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"dev"</span>: <span class="string">"node build/dev-server.js"</span>,</div><div class="line">    <span class="string">"build"</span>: <span class="string">"node build/build.js"</span></div><div class="line">  &#125;,</div></pre></td></tr></table></figure>
<h3 id="2-dependencies字段和devDependencies字段"><a href="#2-dependencies字段和devDependencies字段" class="headerlink" title="2.dependencies字段和devDependencies字段"></a>2.dependencies字段和devDependencies字段</h3><ul>
<li><p>dependencies字段指项目运行时所依赖的模块；</p>
</li>
<li><p>devDependencies字段指定了项目开发时所依赖的模块；</p>
</li>
</ul>
<p>在命令行中运行npm install命令，会自动安装dependencies和devDempendencies字段中的模块。package.json还有很多相关配置，如果你想全面了解，可以专门去百度学习一下。</p>
<h3 id="3-Webpack相关"><a href="#3-Webpack相关" class="headerlink" title="3.Webpack相关"></a>3.Webpack相关</h3><p>我们在上面说了运行npm run dev 就相当于执行了node build/dev-server.js,说明这个文件相当重要，先来熟悉一下它。 我贴出代码并给出重要的解释。</p>
<h4 id="1-dev-server-js"><a href="#1-dev-server-js" class="headerlink" title="1).dev-server.js"></a>1).dev-server.js</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 检查 Node 和 npm 版本</span></div><div class="line"><span class="keyword">require</span>(<span class="string">'./check-versions'</span>)()</div><div class="line"></div><div class="line"><span class="comment">// 获取 config/index.js 的默认配置</span></div><div class="line"><span class="keyword">var</span> config = <span class="keyword">require</span>(<span class="string">'../config'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 如果 Node 的环境无法判断当前是 dev / product 环境</span></div><div class="line"><span class="comment">// 使用 config.dev.env.NODE_ENV 作为当前的环境</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (!process.env.NODE_ENV) process.env.NODE_ENV = JSON.parse(config.dev.env.NODE_ENV)</div><div class="line"></div><div class="line"><span class="comment">// 使用 NodeJS 自带的文件路径工具</span></div><div class="line"><span class="keyword">var</span> path = <span class="keyword">require</span>(<span class="string">'path'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 使用 express</span></div><div class="line"><span class="keyword">var</span> express = <span class="keyword">require</span>(<span class="string">'express'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 使用 webpack</span></div><div class="line"><span class="keyword">var</span> webpack = <span class="keyword">require</span>(<span class="string">'webpack'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 一个可以强制打开浏览器并跳转到指定 url 的插件</span></div><div class="line"><span class="keyword">var</span> opn = <span class="keyword">require</span>(<span class="string">'opn'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 使用 proxyTable</span></div><div class="line"><span class="keyword">var</span> proxyMiddleware = <span class="keyword">require</span>(<span class="string">'http-proxy-middleware'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 使用 dev 环境的 webpack 配置</span></div><div class="line"><span class="keyword">var</span> webpackConfig = <span class="keyword">require</span>(<span class="string">'./webpack.dev.conf'</span>)</div><div class="line"></div><div class="line"><span class="comment">// default port where dev server listens for incoming traffic</span></div><div class="line"></div><div class="line"><span class="comment">// 如果没有指定运行端口，使用 config.dev.port 作为运行端口</span></div><div class="line"><span class="keyword">var</span> port = process.env.PORT || config.dev.port</div><div class="line"></div><div class="line"><span class="comment">// Define HTTP proxies to your custom API backend</span></div><div class="line"><span class="comment">// https://github.com/chimurai/http-proxy-middleware</span></div><div class="line"></div><div class="line"><span class="comment">// 使用 config.dev.proxyTable 的配置作为 proxyTable 的代理配置</span></div><div class="line"><span class="keyword">var</span> proxyTable = config.dev.proxyTable</div><div class="line"></div><div class="line"><span class="comment">// 使用 express 启动一个服务</span></div><div class="line"><span class="keyword">var</span> app = express()</div><div class="line"></div><div class="line"><span class="comment">// 启动 webpack 进行编译</span></div><div class="line"><span class="keyword">var</span> compiler = webpack(webpackConfig)</div><div class="line"></div><div class="line"><span class="comment">// 启动 webpack-dev-middleware，将 编译后的文件暂存到内存中</span></div><div class="line"><span class="keyword">var</span> devMiddleware = <span class="keyword">require</span>(<span class="string">'webpack-dev-middleware'</span>)(compiler, &#123;</div><div class="line">  publicPath: webpackConfig.output.publicPath,</div><div class="line">  stats: &#123;</div><div class="line">    colors: <span class="keyword">true</span>,</div><div class="line">    chunks: <span class="keyword">false</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 启动 webpack-hot-middleware，也就是我们常说的 Hot-reload</span></div><div class="line"><span class="keyword">var</span> hotMiddleware = <span class="keyword">require</span>(<span class="string">'webpack-hot-middleware'</span>)(compiler)</div><div class="line"><span class="comment">// force page reload when html-webpack-plugin template changes</span></div><div class="line">compiler.plugin(<span class="string">'compilation'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(compilation)</span> </span>&#123;</div><div class="line">  compilation.plugin(<span class="string">'html-webpack-plugin-after-emit'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(data, cb)</span> </span>&#123;</div><div class="line">    hotMiddleware.publish(&#123; action: <span class="string">'reload'</span> &#125;)</div><div class="line">    cb()</div><div class="line">  &#125;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// proxy api requests</span></div><div class="line"><span class="comment">// 将 proxyTable 中的请求配置挂在到启动的 express 服务上</span></div><div class="line">Object.keys(proxyTable).<span class="keyword">forEach</span>(<span class="function"><span class="keyword">function</span> <span class="params">(context)</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> options = proxyTable[context]</div><div class="line">  <span class="keyword">if</span> (typeof options === <span class="string">'string'</span>) &#123;</div><div class="line">    options = &#123; target: options &#125;</div><div class="line">  &#125;</div><div class="line">  app.<span class="keyword">use</span>(proxyMiddleware(context, options))</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// handle fallback for HTML5 history API</span></div><div class="line"><span class="comment">// 使用 connect-history-api-fallback 匹配资源，如果不匹配就可以重定向到指定地址</span></div><div class="line">app.<span class="keyword">use</span>(<span class="keyword">require</span>(<span class="string">'connect-history-api-fallback'</span>)())</div><div class="line"></div><div class="line"><span class="comment">// serve webpack bundle output</span></div><div class="line"><span class="comment">// 将暂存到内存中的 webpack 编译后的文件挂在到 express 服务上</span></div><div class="line">app.<span class="keyword">use</span>(devMiddleware)</div><div class="line"></div><div class="line"><span class="comment">// enable hot-reload and state-preserving</span></div><div class="line"><span class="comment">// compilation error display</span></div><div class="line"><span class="comment">// 将 Hot-reload 挂在到 express 服务上</span></div><div class="line">app.<span class="keyword">use</span>(hotMiddleware)</div><div class="line"></div><div class="line"><span class="comment">// serve pure static assets</span></div><div class="line"><span class="comment">// 拼接 static 文件夹的静态资源路径</span></div><div class="line"><span class="keyword">var</span> staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)</div><div class="line"><span class="comment">// 为静态资源提供响应服务</span></div><div class="line">app.<span class="keyword">use</span>(staticPath, express.<span class="keyword">static</span>(<span class="string">'./static'</span>))</div><div class="line"></div><div class="line"><span class="comment">// 让我们这个 express 服务监听 port 的请求，并且将此服务作为 dev-server.js 的接口暴露</span></div><div class="line">module.exports = app.listen(port, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (err) &#123;</div><div class="line">    console.log(err)</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> uri = <span class="string">'http://localhost:'</span> + port</div><div class="line">  console.log(<span class="string">'Listening at '</span> + uri + <span class="string">'\n'</span>)</div><div class="line"></div><div class="line">  <span class="comment">// when env is testing, don't need open it</span></div><div class="line">  <span class="comment">// 如果不是测试环境，自动打开浏览器并跳到我们的开发地址</span></div><div class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'testing'</span>) &#123;</div><div class="line">    opn(uri)</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h4 id="2-webpack-base-confg-js-webpack的基础配置文件"><a href="#2-webpack-base-confg-js-webpack的基础配置文件" class="headerlink" title="2).webpack.base.confg.js   webpack的基础配置文件"></a>2).webpack.base.confg.js   webpack的基础配置文件</h4><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">...</div><div class="line"><span class="keyword">module</span>.<span class="keyword">export</span> = &#123;</div><div class="line">    <span class="comment">// 编译入口文件</span></div><div class="line">    entry: &#123;&#125;,</div><div class="line">    <span class="comment">// 编译输出路径</span></div><div class="line">    output: &#123;&#125;,</div><div class="line">    <span class="comment">// 一些解决方案配置</span></div><div class="line">    resolve: &#123;&#125;,</div><div class="line">    resolveLoader: &#123;&#125;,</div><div class="line">    <span class="keyword">module</span>: &#123;</div><div class="line">        <span class="comment">// 各种不同类型文件加载器配置</span></div><div class="line">        loaders: &#123;</div><div class="line">        ...</div><div class="line">        ...</div><div class="line">        <span class="comment">// js文件用babel转码</span></div><div class="line">        &#123;</div><div class="line">            test: /\.js$/,</div><div class="line">            loader: <span class="string">'babel'</span>,</div><div class="line">            include: projectRoot,</div><div class="line">            <span class="comment">// 哪些文件不需要转码</span></div><div class="line">            exclude: /node_modules/</div><div class="line">        &#125;,</div><div class="line">        ...</div><div class="line">        ...</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// vue文件一些相关配置</span></div><div class="line">    vue: &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-babelrc"><a href="#3-babelrc" class="headerlink" title="3). .babelrc"></a>3). .babelrc</h4><p>Babel解释器的配置文件，存放在根目录下。Babel是一个转码器，项目里需要用它将ES6代码转为ES5代码。如果你想了解更多，可以查看babel的知识。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  //设定转码规则</div><div class="line">  <span class="string">"presets"</span>: [</div><div class="line">    [<span class="string">"env"</span>, &#123; <span class="string">"modules"</span>: <span class="literal">false</span> &#125;],</div><div class="line">    <span class="string">"stage-2"</span></div><div class="line">  ],</div><div class="line">  //转码用的插件</div><div class="line">  <span class="string">"plugins"</span>: [<span class="string">"transform-runtime"</span>],</div><div class="line">  <span class="string">"comments"</span>: <span class="literal">false</span>,</div><div class="line">  //对BABEL_ENV或者NODE_ENV指定的不同的环境变量，进行不同的编译操作</div><div class="line">  <span class="string">"env"</span>: &#123;</div><div class="line">    <span class="string">"test"</span>: &#123;</div><div class="line">      <span class="string">"presets"</span>: [<span class="string">"env"</span>, <span class="string">"stage-2"</span>],</div><div class="line">      <span class="string">"plugins"</span>: [ <span class="string">"istanbul"</span> ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-editorconfig"><a href="#4-editorconfig" class="headerlink" title="4). .editorconfig"></a>4). .editorconfig</h4><p>该文件定义项目的编码规范，编译器的行为会与.editorconfig文件中定义的一致，并且其优先级比编译器自身的设置要高，这在多人合作开发项目时十分有用而且必要。<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">root = <span class="literal">true</span></div><div class="line"></div><div class="line">[*]    <span class="comment">// 对所有文件应用下面的规则</span></div><div class="line">charset = utf<span class="number">-8</span>                    <span class="comment">// 编码规则用utf-8</span></div><div class="line">indent_style = space               <span class="comment">// 缩进用空格</span></div><div class="line">indent_size = <span class="number">2</span>                    <span class="comment">// 缩进数量为2个空格</span></div><div class="line">end_of_line = lf                   <span class="comment">// 换行符格式</span></div><div class="line">insert_final_new<span class="type">line</span> = <span class="literal">true</span>        <span class="comment">// 是否在文件的最后插入一个空行</span></div><div class="line">trim_trailing_whitespace = <span class="literal">true</span>    <span class="comment">// 是否删除行尾的空格</span></div></pre></td></tr></table></figure></p>
<h2 id="四-Vue-cli模板"><a href="#四-Vue-cli模板" class="headerlink" title="四. Vue-cli模板"></a>四. Vue-cli模板</h2><h3 id="1、npm-run-build-命令"><a href="#1、npm-run-build-命令" class="headerlink" title="1、npm run build 命令"></a>1、npm run build 命令</h3><p>我们在命令行中输入npm run build命令后，vue-cli会自动进行项目发布打包。你在package.json文件的scripts字段中可以看出，你执行的npm run build命令就相对执行的 node build/build.js 。</p>
<p>package.json的scripts 字段：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line">  <span class="string">"dev"</span>: <span class="string">"node build/dev-server.js"</span>,</div><div class="line">  <span class="string">"build"</span>: <span class="string">"node build/build.js"</span></div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>在执行完npm run build命令后，在你的项目根目录生成了dist文件夹，这个文件夹里边就是我们要传到服务器上的文件。</p>
<p>dist文件夹下目录包括：</p>
<ul>
<li><p>index.html 主页文件:因为我们开发的是单页web应用，所以说一般只有一个html文件。</p>
</li>
<li><p>static 静态资源文件夹：里边js、CSS和一些图片。</p>
</li>
</ul>
<h3 id="2、main-js文件解读"><a href="#2、main-js文件解读" class="headerlink" title="2、main.js文件解读"></a>2、main.js文件解读</h3><p>main.js是整个项目的入口文件,在src文件夹下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>      </div><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></div><div class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></div><div class="line"></div><div class="line">Vue.config.productionTip = <span class="literal">false</span>   <span class="comment">//生产环境提示，这里设置成了false</span></div><div class="line"></div><div class="line"><span class="comment">/* eslint-disable no-new */</span></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">el</span>: <span class="string">'#app'</span>,</div><div class="line">  router,</div><div class="line">  <span class="attr">template</span>: <span class="string">'&lt;App/&gt;'</span>,</div><div class="line">  <span class="attr">components</span>: &#123; App &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>通过代码可以看出这里引进了App的组件和<app>的模板，它是通过 import App from ‘./App’这句代码引入的。  我们找到App.vue文件，打开查看。</app></p>
<h3 id="3、App-vue文件"><a href="#3、App-vue文件" class="headerlink" title="3、App.vue文件:"></a>3、App.vue文件:</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./assets/logo.png"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'app'</span></div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line"><span class="selector-id">#app</span> &#123;</div><div class="line">  <span class="attribute">font-family</span>: <span class="string">'Avenir'</span>, Helvetica, Arial, sans-serif;</div><div class="line">  <span class="attribute">-webkit-font-smoothing</span>: antialiased;</div><div class="line">  <span class="attribute">-moz-osx-font-smoothing</span>: grayscale;</div><div class="line">  <span class="attribute">text-align</span>: center;</div><div class="line">  <span class="attribute">color</span>: <span class="number">#2c3e50</span>;</div><div class="line">  <span class="attribute">margin-top</span>: <span class="number">60px</span>;</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure>
<p>app.vue文件我们可以分成三部分解读，</p>
<ul>
<li><p>template标签包裹的内容：这是模板的HTMLDom结构，里边引入了一张图片和router-view标签，router-view标签说明使用了路由机制。我们会在以后专门拿出一篇文章讲Vue-router。</p>
</li>
<li><p>script标签包括的js内容：你可以在这里些一些页面的动态效果和Vue的逻辑代码。</p>
</li>
<li><p>style标签包裹的css内容：这里就是你平时写的CSS样式，对页面样子进行装饰用的，需要特别说明的是你可以用style scoped来声明这些css样式只在本模板中起作用。</p>
</li>
</ul>
<h3 id="4、router-index-js-路由文件"><a href="#4、router-index-js-路由文件" class="headerlink" title="4、router/index.js 路由文件"></a>4、router/index.js 路由文件</h3><p>引文在app.vue中我们看到了路由文件，虽然router的内容比较多，但是我们先简单的看一下。下篇文章我们就开始讲Vue-router。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></div><div class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></div><div class="line"><span class="keyword">import</span> Hello <span class="keyword">from</span> <span class="string">'@/components/Hello'</span></div><div class="line"></div><div class="line">Vue.use(Router)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</div><div class="line">  <span class="attr">routes</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="attr">path</span>: <span class="string">'/'</span>,</div><div class="line">      <span class="attr">name</span>: <span class="string">'Hello'</span>,</div><div class="line">      <span class="attr">component</span>: Hello</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>我们可以看到 import Hello from ‘@/components/Hello’这句话， 文件引入了/components/Hello.vue文件。这个文件里就配置了一个路由，就是当我们访问网站时给我们显示Hello.vue的内容。</p>
<h3 id="5、Hello-vue文件解读："><a href="#5、Hello-vue文件解读：" class="headerlink" title="5、Hello.vue文件解读："></a>5、Hello.vue文件解读：</h3><p>这个文件就是我们在第一节课看到的页面文件了。也是分为template、script、style三个部分，以后我们大部分的工作都是写这些.vue结尾的文件。现在我们可以试着改一些内容，然后预览一下。</p>
<figure class="highlight django"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hello"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="template-variable">&#123;&#123; msg &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Essential Links<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://vuejs.org"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>Core Docs<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://forum.vuejs.org"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>Forum<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://gitter.im/vuejs/vue"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>Gitter Chat<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://twitter.com/vuejs"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>Twitter<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://vuejs-templates.github.io/webpack/"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>Docs for This Template<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Ecosystem<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://router.vuejs.org/"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>vue-router<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://vuex.vuejs.org/"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>vuex<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://vue-loader.vuejs.org/"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>vue-loader<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://github.com/vuejs/awesome-vue"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>awesome-vue<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'hello'</span>,</div><div class="line">  data () &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">msg</span>: <span class="string">'Welcome to Your Vue.js App'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- Add "scoped" attribute to limit CSS to this component only --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="css"></span></div><div class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span> &#123;</div><div class="line">  <span class="attribute">font-weight</span>: normal;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">ul</span> &#123;</div><div class="line">  <span class="attribute">list-style-type</span>: none;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">li</span> &#123;</div><div class="line">  <span class="attribute">display</span>: inline-block;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">10px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">a</span> &#123;</div><div class="line">  <span class="attribute">color</span>: <span class="number">#42b983</span>;</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五. 总结"></a>五. 总结</h2><p>以上就是有关Vue-cli项目结构的所有分析了，俗话说得好：赢在起跑线上才是最重要的。了解清楚了脚手架的项目结构，以后撸代码思路就会很清晰，少走很多弯路，与君共勉。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习Vue.js框架，正打算做一个小项目练练手。第一步当然少不了强大的Vue-cli脚手架工具。那么什么是Vue-cli呢？
    
    </summary>
    
      <category term="JavaScript" scheme="https://tancky.github.io/categories/JavaScript/"/>
    
    
      <category term="Vue.js" scheme="https://tancky.github.io/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS原理详解</title>
    <link href="https://tancky.github.io/2017/06/18/HTTPS%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>https://tancky.github.io/2017/06/18/HTTPS原理详解/</id>
    <published>2017-06-18T06:55:52.266Z</published>
    <updated>2017-06-18T07:03:56.051Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>HTTPS（全称：HyperText Transfer Protocol over Secure Socket Layer），其实 HTTPS 并不是一个新鲜协议，Google 很早就开始启用了，初衷是为了保证数据安全。 近两年，Google、Baidu、Facebook 等这样的互联网巨头，不谋而合地开始大力推行 HTTPS， 国内外的大型互联网公司很多也都已经启用了全站 HTTPS，这也是未来互联网发展的趋势。<a id="more"></a></p>
</blockquote>
<p>为鼓励全球网站的 HTTPS 实现，一些互联网公司都提出了自己的要求：</p>
<p>1）Google 已调整搜索引擎算法，让采用 HTTPS 的网站在搜索中排名更靠前；</p>
<p>2）从 2017 年开始，Chrome 浏览器已把采用 HTTP 协议的网站标记为不安全网站；</p>
<p>3）苹果要求 2017 年 App Store 中的所有应用都必须使用 HTTPS 加密连接；</p>
<p>4）当前国内炒的很火热的微信小程序也要求必须使用 HTTPS 协议；</p>
<p>5）新一代的 HTTP/2 协议的支持需以 HTTPS 为基础。</p>
<p>等等，因此想必在不久的将来，全网 HTTPS 势在必行。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>1、HTTP 协议（HyperText Transfer Protocol，超文本传输协议）：是客户端浏览器或其他程序与Web服务器之间的应用层通信协议 。</p>
<p>2、HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输。</p>
<blockquote>
<p>HTTPS 相比 HTTP 多了一层 SSL/TLS</p>
</blockquote>
<p>SSL（Secure Socket Layer，安全套接字层）：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。</p>
<p>TLS（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。</p>
<h2 id="加密算法："><a href="#加密算法：" class="headerlink" title="加密算法："></a>加密算法：</h2><p>据记载，公元前400年，古希腊人就发明了置换密码；在第二次世界大战期间，德国军方启用了“恩尼格玛”密码机，所以密码学在社会发展中有着广泛的用途。</p>
<h4 id="1、对称加密"><a href="#1、对称加密" class="headerlink" title="1、对称加密"></a>1、对称加密</h4><p>有流式、分组两种，加密和解密都是使用的同一个密钥。</p>
<p>例如：DES、AES-GCM、ChaCha20-Poly1305等</p>
<h4 id="2、非对称加密"><a href="#2、非对称加密" class="headerlink" title="2、非对称加密"></a>2、非对称加密</h4><p>加密使用的密钥和解密使用的密钥是不相同的，分别称为：公钥、私钥，公钥和算法都是公开的，私钥是保密的。非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。</p>
<p>例如：RSA、DSA、ECDSA、 DH、ECDHE</p>
<h4 id="3、哈希算法"><a href="#3、哈希算法" class="headerlink" title="3、哈希算法"></a>3、哈希算法</h4><p>将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。</p>
<p>例如：MD5、SHA-1、SHA-2、SHA-256 等</p>
<h4 id="4、数字签名"><a href="#4、数字签名" class="headerlink" title="4、数字签名"></a>4、数字签名</h4><p>签名就是在信息的后面再加上一段内容（信息经过hash后的值），可以证明信息没有被修改过。hash值一般都会加密后（也就是签名）再和信息一起发送，以保证这个hash值不被修改。</p>
<h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><h3 id="一、HTTP-访问过程"><a href="#一、HTTP-访问过程" class="headerlink" title="一、HTTP 访问过程"></a>一、HTTP 访问过程</h3><p><img src="https://ooo.0o0.ooo/2017/06/18/5946217371888.png" alt="我的头像"></p>
<p>抓包如下：<br><img src="https://ooo.0o0.ooo/2017/06/18/59461ed083a90.png" alt="我的头像"></p>
<p>如上图所示，HTTP请求过程中，客户端与服务器之间没有任何身份确认的过程，数据全部明文传输，“裸奔”在互联网上，所以很容易遭到黑客的攻击，如下：<br><img src="https://ooo.0o0.ooo/2017/06/18/59461eef7e481.png" alt="我的头像"></p>
<p>可以看到，客户端发出的请求很容易被黑客截获，如果此时黑客冒充服务器，则其可返回任意信息给客户端，而不被客户端察觉，所以我们经常会听到一词“劫持”，现象如下：</p>
<p>下面两图中，浏览器中填入的是相同的URL，左边是正确响应，而右边则是被劫持后的响应<br><img src="https://ooo.0o0.ooo/2017/06/18/59461f526e481.png" alt="我的头像"></p>
<p>所以 HTTP 传输面临的风险有：</p>
<p>（1） 窃听风险：黑客可以获知通信内容。</p>
<p>（2） 篡改风险：黑客可以修改通信内容。</p>
<p>（3） 冒充风险：黑客可以冒充他人身份参与通信。</p>
<h3 id="二、HTTP-向-HTTPS-演化的过程"><a href="#二、HTTP-向-HTTPS-演化的过程" class="headerlink" title="二、HTTP 向 HTTPS 演化的过程"></a>二、HTTP 向 HTTPS 演化的过程</h3><p>第一步：为了防止上述现象的发生，人们想到一个办法：对传输的信息加密（即使黑客截获，也无法破解）<br><img src="https://ooo.0o0.ooo/2017/06/18/59461f614cafa.png" alt="我的头像"></p>
<p>如上图所示，此种方式属于对称加密，双方拥有相同的密钥，信息得到安全传输，但此种方式的缺点是：</p>
<p>（1）不同的客户端、服务器数量庞大，所以双方都需要维护大量的密钥，维护成本很高</p>
<p>（2）因每个客户端、服务器的安全级别不同，密钥极易泄露</p>
<p>第二步：既然使用对称加密时，密钥维护这么繁琐，那我们就用非对称加密试试</p>
<p><img src="https://ooo.0o0.ooo/2017/06/18/59461f6ee664e.png" alt="我的头像"><br>如上图所示，客户端用公钥对请求内容加密，服务器使用私钥对内容解密，反之亦然，但上述过程也存在缺点：</p>
<p>（1）公钥是公开的（也就是黑客也会有公钥），所以第 ④ 步私钥加密的信息，如果被黑客截获，其可以使用公钥进行解密，获取其中的内容</p>
<p>第三步：非对称加密既然也有缺陷，那我们就将对称加密，非对称加密两者结合起来，取其精华、去其糟粕，发挥两者的各自的优势<br><img src="https://ooo.0o0.ooo/2017/06/18/59461f8686a15.png" alt="我的头像"></p>
<p>如上图所示</p>
<p>（1）第 ③ 步时，客户端说：（咱们后续回话采用对称加密吧，这是对称加密的算法和对称密钥）这段话用公钥进行加密，然后传给服务器</p>
<p>（2）服务器收到信息后，用私钥解密，提取出对称加密算法和对称密钥后，服务器说：（好的）对称密钥加密</p>
<p>（3）后续两者之间信息的传输就可以使用对称加密的方式了</p>
<p>遇到的问题：</p>
<p>（1）客户端如何获得公钥</p>
<p>（2）如何确认服务器是真实的而不是黑客</p>
<p>第四步：获取公钥与确认服务器身份<br><img src="https://ooo.0o0.ooo/2017/06/18/59461f9e4ec17.png" alt=""></p>
<h4 id="1、获取公钥"><a href="#1、获取公钥" class="headerlink" title="1、获取公钥"></a>1、获取公钥</h4><p>（1）提供一个下载公钥的地址，回话前让客户端去下载。（缺点：下载地址有可能是假的；客户端每次在回话前都先去下载公钥也很麻烦）（2）回话开始时，服务器把公钥发给客户端（缺点：黑客冒充服务器，发送给客户端假的公钥）</p>
<h4 id="2、那有木有一种方式既可以安全的获取公钥，又能防止黑客冒充呢？-那就需要用到终极武器了：SSL-证书（申购）"><a href="#2、那有木有一种方式既可以安全的获取公钥，又能防止黑客冒充呢？-那就需要用到终极武器了：SSL-证书（申购）" class="headerlink" title="2、那有木有一种方式既可以安全的获取公钥，又能防止黑客冒充呢？ 那就需要用到终极武器了：SSL 证书（申购）"></a>2、那有木有一种方式既可以安全的获取公钥，又能防止黑客冒充呢？ 那就需要用到终极武器了：SSL 证书（申购）</h4><p><img src="https://ooo.0o0.ooo/2017/06/18/59461fb91999b.png" alt=""></p>
<p>如上图所示，在第 ② 步时服务器发送了一个SSL证书给客户端，SSL 证书中包含的具体内容有：</p>
<p>（1）证书的发布机构CA</p>
<p>（2）证书的有效期</p>
<p>（3）公钥</p>
<p>（4）证书所有者</p>
<p>（5）签名</p>
<p>………</p>
<h4 id="3、客户端在接受到服务端发来的SSL证书时，会对证书的真伪进行校验，以浏览器为例说明如下："><a href="#3、客户端在接受到服务端发来的SSL证书时，会对证书的真伪进行校验，以浏览器为例说明如下：" class="headerlink" title="3、客户端在接受到服务端发来的SSL证书时，会对证书的真伪进行校验，以浏览器为例说明如下："></a>3、客户端在接受到服务端发来的SSL证书时，会对证书的真伪进行校验，以浏览器为例说明如下：</h4><p>（1）首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验</p>
<p>（2）浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发</p>
<p>（3）如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。</p>
<p>（4）如果找到，那么浏览器就会从操作系统中取出 颁发者CA 的公钥，然后对服务器发来的证书里面的签名进行解密</p>
<p>（5）浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比</p>
<p>（6）对比结果一致，则证明服务器发来的证书合法，没有被冒充</p>
<p>（7）此时浏览器就可以读取证书中的公钥，用于后续加密了</p>
<h4 id="4、所以通过发送SSL证书的形式，既解决了公钥获取问题，又解决了黑客冒充问题，一箭双雕，HTTPS加密过程也就此形成"><a href="#4、所以通过发送SSL证书的形式，既解决了公钥获取问题，又解决了黑客冒充问题，一箭双雕，HTTPS加密过程也就此形成" class="headerlink" title="4、所以通过发送SSL证书的形式，既解决了公钥获取问题，又解决了黑客冒充问题，一箭双雕，HTTPS加密过程也就此形成"></a>4、所以通过发送SSL证书的形式，既解决了公钥获取问题，又解决了黑客冒充问题，一箭双雕，HTTPS加密过程也就此形成</h4><p>所以相比HTTP，HTTPS 传输更加安全</p>
<p>（1） 所有信息都是加密传播，黑客无法窃听。</p>
<p>（2） 具有校验机制，一旦被篡改，通信双方会立刻发现。</p>
<p>（3） 配备身份证书，防止身份被冒充。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，相比 HTTP 协议，HTTPS 协议增加了很多握手、加密解密等流程，虽然过程很复杂，但其可以保证数据传输的安全。所以在这个互联网膨胀的时代，其中隐藏着各种看不见的危机，为了保证数据的安全，维护网络稳定，建议大家多多推广HTTPS。</p>
<p>原文转自<a href="https://segmentfault.com/p/1210000009779379" target="_blank" rel="external">https://segmentfault.com/p/1210000009779379</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;HTTPS（全称：HyperText Transfer Protocol over Secure Socket Layer），其实 HTTPS 并不是一个新鲜协议，Google 很早就开始启用了，初衷是为了保证数据安全。 近两年，Google、Baidu、Facebook 等这样的互联网巨头，不谋而合地开始大力推行 HTTPS， 国内外的大型互联网公司很多也都已经启用了全站 HTTPS，这也是未来互联网发展的趋势。
    
    </summary>
    
      <category term="http协议" scheme="https://tancky.github.io/categories/http%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="http协议" scheme="https://tancky.github.io/tags/http%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>理解JavaScript中的事件委托</title>
    <link href="https://tancky.github.io/2016/12/21/%E7%90%86%E8%A7%A3JavaScript%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
    <id>https://tancky.github.io/2016/12/21/理解JavaScript中的事件委托/</id>
    <published>2016-12-21T10:53:31.803Z</published>
    <updated>2016-12-21T11:01:42.992Z</updated>
    
    <content type="html"><![CDATA[<p>在我们平常工作或学习编写JS代码的过程中，经常会做的一件事就是给某个元素绑定事件。<a id="more"></a>例如鼠标点击，移入，移出等等，以响应用户的某种行为，举个栗子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn=<span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</div><div class="line">    btn.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="string">"hello world!"</span>);    </div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>上述的栗子是当用户点击某个按钮时会弹出对话框显示”hello world” 。但是在某些情况下，我们期望页面上的一些元素响应用户同样的动作，举个例子。在用户点击列表的每一项时，将其内容显示在div里。例如这样：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;ul class="list"&gt;</div><div class="line">    &lt;li&gt;1&lt;/li&gt;</div><div class="line">    &lt;li&gt;2&lt;/li&gt;</div><div class="line">    &lt;li&gt;3&lt;/li&gt;</div><div class="line">    &lt;li&gt;4&lt;/li&gt;</div><div class="line">    &lt;li&gt;5&lt;/li&gt;</div><div class="line">    …</div><div class="line">    &lt;li&gt;100&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">&lt;div class="list-show"&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>用JQuery我们可以这么做：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'.list li'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    $(<span class="string">'.list-show'</span>).html($(<span class="keyword">this</span>).html());</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>其实就是给列表的每一项（100个）分别绑定了点击事件。这样做的弊端在于，增加了内存，因为\$(.list li)里有100个li对象。同时降低了代码性能，因为$(’.list li’)会搜索ul下所有的li元素。</p>
<h3 id="那么有没有更好的方法呢？"><a href="#那么有没有更好的方法呢？" class="headerlink" title="那么有没有更好的方法呢？"></a>那么有没有更好的方法呢？</h3><p>当然有，那就是事件委托！上面代码也可以这样写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'.list'</span>).on(<span class="string">'click'</span>, <span class="string">'li'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    $(<span class="string">'.list-show'</span>).html($(<span class="keyword">this</span>).html());</div><div class="line">&#125;);        <span class="comment">//jquery都是用on绑定事件。jquery规定on()中的第二个参数如果是dom元素，则为事件委托，否则为正常的事件绑定。</span></div></pre></td></tr></table></figure></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>什么是事件委托<br>事件委托又称事件代理（话说之前我以为这两个是不一样的概念…），用网上很经典的一个场景来描述就是取快递：</li>
</ul>
<blockquote>
<p>有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。</p>
<p>这里其实还有2层意思的：</p>
<p>第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的；</p>
<p>第二，新员工也是可以被前台MM代为签收的，即程序中新添加的dom节点也是有事件的。</p>
</blockquote>
<ul>
<li><p>事件委托的原理</p>
<p>事件委托其实就是利用的事件冒泡的原理，而事件冒泡就是事件开始时由最具体的元素（文档中嵌套层次最深的那个节点接收），然后逐级向上传播到最不为具体的节点（文档）。</p>
<p>在本文最开始举例的代码中可以看出：</p>
<p>将li元素的点击事件委托给其父元素ul。这么做之所以行得通，是因为事件具有冒泡的特点，当内层元素的某个事件被触发，事件会一级一级冒泡到更外层元素。当外层元素被绑定事件且被触发时，判断事件的来源即event.target是否是目标元素li，如果是就执行回调。上面的代码等价于：</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">showText</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">    $(<span class="string">'.list-show'</span>).html(text);</div><div class="line">&#125;</div><div class="line"></div><div class="line">$(<span class="string">'.list'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> $target = $(event.target);</div><div class="line">    <span class="keyword">if</span> ($target.is(<span class="string">'li'</span>)) &#123;</div><div class="line">        showText($target.html());</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>事件委托的优点</li>
</ul>
<p>A.使用事件委托可以明显减少dom的操作次数，优化性能和节约内存空间。<br>B.新添加的元素依然会有之前添加的事件（即新来的员工也能收到快递）。在上例中，如果通过AJAX向列表增加新项，新添加项仍能响应用户点击。在页面动态变化后，不需要重新检索元素和绑定事件。</p>
<p>本文完！</p>
<p>撒花！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我们平常工作或学习编写JS代码的过程中，经常会做的一件事就是给某个元素绑定事件。
    
    </summary>
    
      <category term="JavaScript" scheme="https://tancky.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://tancky.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的数据类型</title>
    <link href="https://tancky.github.io/2016/12/17/JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://tancky.github.io/2016/12/17/JavaScript中的数据类型/</id>
    <published>2016-12-17T12:41:05.683Z</published>
    <updated>2016-12-21T10:57:24.301Z</updated>
    
    <content type="html"><![CDATA[<p>今天继续夯实基础，写一写Js中的数据类型，理清楚概念才能少踩一些没必要的坑，特别是对于很多初学者而言（好吧，包括我在内）很容易弄混淆的东西。<a id="more"></a></p>
<h2 id="两类数据类型"><a href="#两类数据类型" class="headerlink" title="两类数据类型"></a>两类数据类型</h2><p>众所周知，JS中有六种数据类型，按全球JS顶尖专家Nicholas Zakas的说法，JS中数据类型又分成两大类：第一种是简单的数据类型（原始类型）：Undefined,Null,Boolean,Number以及String，其二是复杂的数据类型（引用类型）——object，而object本质上是由一组无序的名值对组成的。在ECMAScript中不支持任何创建自定义类型的机制，所有的值最终都将是上述的6种数据类型之一。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a=<span class="number">100</span>;    <span class="comment">//此时a为number类型</span></div><div class="line"></div><div class="line">a=<span class="literal">true</span>;      <span class="comment">//此时a为boolean类型</span></div><div class="line"></div><div class="line">a=<span class="string">"Hello,JavaScript!"</span>; <span class="comment">//此时a为string类型</span></div><div class="line"></div><div class="line">a=&#123;&#125;;        <span class="comment">//此时a为object类型</span></div><div class="line"></div><div class="line">a=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;  <span class="comment">//此时a为function类型,也是属于对象类型</span></div></pre></td></tr></table></figure></p>
<h3 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h3><p>由于JS是一种弱类型的编程语言，所以需要有一种手段来检测给定变量的数据类型——typeof操作符。举个栗子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> msg=<span class="string">"Hello World"</span></div><div class="line">alert(<span class="keyword">typeof</span> msg);    <span class="comment">//"string"</span></div><div class="line">alert(<span class="keyword">typeof</span>(msg));    <span class="comment">//"string"</span></div><div class="line">alert(<span class="keyword">typeof</span> <span class="number">37</span>);    <span class="comment">//"number"</span></div></pre></td></tr></table></figure></p>
<h2 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h2><ul>
<li>Undefined类型</li>
</ul>
<p>Undefined类型只有一个值叫—不存在！这个不存在在JS中就是undefined, 就是英文的原意：『未定义』，但我总觉得这个文绉绉的词其实不好理解。不如把它理解为不存在更然人明白些。在使用var 声明变量但没有初始化的时候，这个变量的值就是undefined。再举个栗子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> msg；</div><div class="line">alert(msg == <span class="literal">undefined</span>);    <span class="comment">//true;</span></div></pre></td></tr></table></figure>
<p>A. 如果一个函数没有返回值，其实就是它的返回值为undefined,即它的返回值不存在。<br>B. 访问一个对象所没有的属性？对不起，得到的是undefined, 即这个属性不存在。<br>C. 代码中写了：var a; console.log(a); 得到undefined, 即这个a不存在，你会争辩：可我明明写了var a;a在我的代码中啊，对的！但这就好比我们人类在这个世界可以把那些没法证实已经存在的东西专门起个名字–叫『不存在』一样。你可以提到它，但它真的不存在。它的名字就叫：不存在。</p>
<ul>
<li>Null类型</li>
</ul>
<p>之前看过一个大神的文章里面，他是这么来谈null类型的:</p>
<blockquote>
<p>很多书上喜欢把程序中的变量比喻成一个盒子，里面装的内容就是变量的值。盒子中装的内容是可以变化的，所以叫变量。这个比喻很形象。先赞一下。</p>
<p>如果你送个你女朋友一个礼物盒，里面装得有礼物，用JS的话来说，你给了她一个变量（因为下次你可能用同样的礼物盒子，但装另外的礼物），如果你只是给了她一个空盒子，用JS的话来比喻，你给了她一个空值，就是null,里面什么也没有装（当然你会被她痛扁的），但这个盒子是存在的，不是undefined的。</p>
<p>但这个空盒子的类型是什么？typeof(null), 返回居然是’object’, 它是对象类型？它不是原始类型？它居然是引用类型？有没有搞错？是的，但不是我们搞错了，是JS的设计者搞错了，但他就是这么设计的。</p>
</blockquote>
<p>由于JS是一个外国大牛仅仅花了十天的时间便创造出来的一门编程语言,现在已经发展到满世界这么流行了，此人已经灰常牛了，如果他不犯一点点错误，还叫我们这样智力平平但又靠写代码为生的码农怎么混？还要不要我们活了？他犯错了，说明他是人，不是神！</p>
<p>虽然很多书中把null叫做空对象, 但按照Nicholas Zakas这样全球顶尖JS高手的归类，它不是引用类型，它应该归于原始类型，只是它是一种特殊的原始类型，尽管typeof(null)返回’object’。</p>
<ul>
<li>Boolean类型</li>
</ul>
<p>Boolean类型（又叫布尔类型）是JS种使用的最多的一种数据类型。他只会返回两个值（布尔值）：ture或者false，且只能是小写。其他混合大小的形式都不是布尔值，只是标识符。</p>
<p>其它类型是可以转换成布尔类型的。转换规则如下：</p>
<p>A. 正零、负零、浮点零（0.0）、空字符串、false本身、NaN、null、undefined 被转换为假值（false）<br>B. 其它值被转换为真值(true), 特别是对象—哪怕是空对象，也会被转换成真值true<br>C. 如果x是要转换成布尔类型的值，就调用Boolean(x)，你也可以写成：!!x 即可。</p>
<ul>
<li>Number类型</li>
</ul>
<p>JS中不管整数还是浮点数，统一归于number类型（数值类型），不像Java那样分为整形和浮点型，整形里面又分为byte,short,int,long 类型，浮点数里面又分为float,double类型，总之，JS中，数值都是number类型，可以用类型操作符typeof（x）来判断，如果返回的是一个字符串’number’, 则表明x 就是number类型。</p>
<p>其实，JS中的数值都是浮点数，例如有：10===10.0 //true.</p>
<p>需要注意的有：<br>(1) NaN（Not a Number—非数值）是一种特殊的数值类型, typeof(NaN),得到的还是’number’ 它不应该参与任何数值类型的运算。它和自己都不相等，无论NaN == NaN, 还是NaN === NaN，得到的都是false. 任何其它的数值类型和NaN进行运算，得到的都是NaN.</p>
<p>(2) 正无穷大表示为Infinity, 负无穷大表示为-Infinity, 它们也是特殊的number类型。</p>
<p>(3) 四则运算中任何一个数值类型除以0，得到Infinity, 但0/0会得到NaN, 这些也不必死记，需要时可以打开Node的命令行验证一下即可。</p>
<p>(4)不是所有的其它类型都可以转化为数值类型，这个需要看情况而定。转换时，如果要转换为整数，可以用parseInt()函数，如果要转换为浮点数，可以用parseFloat(), 注意没有parseDouble()函数，也可以用函数Number(),但某些值和用parseInt()/parseFloat()函数有一些区别。拿不准时，可以先用Node命令行简单测试一些，采用最合理的转换函数，避免bug.</p>
<p>(5)最后请记住：浮点数的运算始终会有误差，能用整数时，尽量用整数。</p>
<ul>
<li>String类型</li>
</ul>
<p>A. JS中没有单独的字符类型，无论单个的字符还是一个字符串都是属于string类型，string类型在JS中属于原始类型，并不像其他语言例如Java中那样，字符串是对象，这是一个很显著的区别。</p>
<p>B. JS中的字符串可以用英文的单引号或双引号包裹起来，如’A’, “ABCD”,’Hello,world’.</p>
<p>C. JS中的空字符串就是’’或””,单引号和双引号之间什么也没有，连空格也不能有。</p>
<p>D. 字符串类型有一个属性叫length,它表示这个字符串的长度（字符的个数），无论中英文字符串中，每个字符都只算一个占位，（千万别混淆：中文字符占2个字节），</p>
<p>举个栗子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1=<span class="string">'abcd'</span>;</div><div class="line"><span class="keyword">var</span> s2=<span class="string">"中国人民"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(s1.length); <span class="comment">//4</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(s2.length); <span class="comment">//4</span></div></pre></td></tr></table></figure></p>
<p>JS中的原始类型也有一些属性和方法，例如这次说的字符串类型，还有toUpperCase(),toLowerCase()方法等等。字符串类型也可以通过方括号语法，用下标来读取位于某个位置的字符，如: var s=’abcde’, 则可以用s[3]来读取下标是3的字符，即：’d’, 字符串的下标仍以0开始，和数组下标一样的开始位置，但JS中字符类型完全不同于JS中的数组类型。后者是引用类型，后面再说吧。</p>
<p>其他任何的类型都可以转化为字符串类型，使用函数String(x), 注意：S要大写，前面不加new运算符，x是要转化为字符串类型的一个值。至于null, undefined,函数等可以转化为字符串类型吗？当然可以，你自己用String( )函数试试看吧。</p>
<p>如果要判断一个变量或一个值是否为字符串类型，可以使用类型操作符typeof x, 也可以写成typeof(x), 如果得到的返回是一个字符串：’string’, 那x就是字符串类型了。此处要注意typeof(x)的写法并不是函数调用，只是这种书写看起来像函数调用罢了，别混淆了，提醒你，JS中处处有坑。</p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>引用类型是一种用于将数据和功能组织在一起的数据结构（也常被成为类），引用类型的值（对象）是引用类型的一个实例。</p>
<p>但是JS中没有类的概念，因此引用类型也可以被称为对象定义，因为他们描述的是一类对象所具有的属性和方法。</p>
<p>对象是某个特定引用类型的实例，新对象是使用new操作符后跟一个构造函数来创建的，构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。</p>
<p>Object是最基本的类型，其他所有类型都继承了它的行为。在举个栗子：</p>
<p>1.Array类型</p>
<p>除了Object之外，Array算是JS最常用最常用的类型。js中的数组与其他语言的数组都是数据的有序列表，但是，数组的每一项可以保存任何类型的数据</p>
<p>2.Date类型</p>
<p>Js中用于构建日期对象的引用类型</p>
<p>3.RegExp类型</p>
<p>Js通过RegExp类型来支持正则表达式</p>
<p>4.Function类型</p>
<p>Js中的函数实际上是对象，每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">       <span class="keyword">return</span> num1 + num2;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>这与使用函数表达式定义函数的方法几乎相差无几：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>本文完！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天继续夯实基础，写一写Js中的数据类型，理清楚概念才能少踩一些没必要的坑，特别是对于很多初学者而言（好吧，包括我在内）很容易弄混淆的东西。
    
    </summary>
    
      <category term="JavaScript" scheme="https://tancky.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://tancky.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>小Tips：Js和JQuery中获得当前索引值的方法</title>
    <link href="https://tancky.github.io/2016/12/15/%E5%B0%8FTips%EF%BC%9AJs%E5%92%8CJQuery%E4%B8%AD%E8%8E%B7%E5%BE%97%E5%BD%93%E5%89%8D%E7%B4%A2%E5%BC%95%E5%80%BC%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://tancky.github.io/2016/12/15/小Tips：Js和JQuery中获得当前索引值的方法/</id>
    <published>2016-12-15T12:52:15.324Z</published>
    <updated>2016-12-15T12:59:06.881Z</updated>
    
    <content type="html"><![CDATA[<p>自从用了Jquery库以后，感觉写Js代码没有那么繁琐了，之前自己用JQuery仿京东首页做了一个轮播图（就差无缝切换了…），代码量仅仅用了几十行，后来打算用原生JS写一遍的时候就悲剧了。<a id="more"></a>上百行的代码量，而且JQuery用多了，自己竟然连获取原生JS中的当前索引值都不会了，还是要好好补补原生JS，基础很重要！基础很重要！基础很重要！重要的事情说三遍！所以，今天就记录下曾经踩过的坑，长个记性！<br>在一些常见的特效里比如轮播图，下拉列表，Tab切换里都会用到循环遍历取得当前索引值并添加事件的方法，在JS中取得当前索引的方法是：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>7<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>8<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;                        <span class="comment">//当页面全部加载完毕后执行</span></div><div class="line">        <span class="keyword">var</span> oUl=<span class="built_in">document</span>.getElementById(<span class="string">"test"</span>), <span class="comment">//获取父元素ul</span></div><div class="line">            oli=oUl.getElementsByTagName(<span class="string">"li"</span>);  <span class="comment">//获取所有的子元素li</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;oli.length; i++)&#123;         <span class="comment">//循环遍历每一个li元素</span></div><div class="line">                                                </div><div class="line">            oli[i].index=i;                      <span class="comment">//重点来了（Js中获取当前索引值的方法）</span></div><div class="line">            </div><div class="line">            oli[i].onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;           <span class="comment">//给当前元素添加点击事件</span></div><div class="line">               alert(<span class="keyword">this</span>.index);                <span class="comment">//输出当前的索引值</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上就是原生JS中获取当前索引的方法，其实不难就那么一行代码，虽然当时困扰了我很久….接下来就来写JQuery中的方法，这个就更简单啦！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    $(<span class="string">"#test li"</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">			<span class="keyword">var</span> me=$(<span class="keyword">this</span>);         <span class="comment">//将当前元素存入名为me的变量里</span></div><div class="line"></div><div class="line">			index=me.index();              <span class="comment">//获取当前的索引值</span></div><div class="line">			alert（index）；               <span class="comment">//输出当前的索引值</span></div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到没，JQuery代码就是这么简单，因为JQuery中提供了index() 方法，该方法返回指定元素相对于其他指定元素的索引值。</p>
<p>写个笔记，给自己提个醒，同样的坑不能掉下去两次了！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从用了Jquery库以后，感觉写Js代码没有那么繁琐了，之前自己用JQuery仿京东首页做了一个轮播图（就差无缝切换了…），代码量仅仅用了几十行，后来打算用原生JS写一遍的时候就悲剧了。
    
    </summary>
    
      <category term="JavaScript" scheme="https://tancky.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://tancky.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>那些年我们一起踩过的坑——CSS中的命名及书写建议</title>
    <link href="https://tancky.github.io/2016/12/13/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91%E2%80%94%E2%80%94CSS%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E5%8F%8A%E4%B9%A6%E5%86%99%E5%BB%BA%E8%AE%AE/"/>
    <id>https://tancky.github.io/2016/12/13/那些年我们一起踩过的坑——CSS中的命名及书写建议/</id>
    <published>2016-12-13T13:49:14.260Z</published>
    <updated>2016-12-13T18:44:42.195Z</updated>
    
    <content type="html"><![CDATA[<p>今天来谈一谈我之前踩过的CSS坑之命名问题，相信很多跟我一样最开始学习CSS的时候都不知道怎样命名，有的起名字直接就是a，b，c，d（至少我初学的时候真的这么干过），更有甚者也会用汉语拼音来命名（例如这样：toubu，neirong，dibu等等），这些命名都是非常不好的习惯，在碰到很多复杂的页面布局时，这样命名会使自己不知所措，找一个class找很久都找不到，非常影响工（xue）作（xi）效率。<a id="more"></a>经过我的多番搜寻与总结下，写了这篇博文。</p>
<h2 id="为什么需要命名规范？"><a href="#为什么需要命名规范？" class="headerlink" title="为什么需要命名规范？"></a>为什么需要命名规范？</h2><blockquote>
<p>合理、科学地对CSS代码命名,能够精简CSS代码,提高代码的开发效率,方便在日常工作中对网站进行维护与修改.遵循W3C所规定的语义化标准。</p>
</blockquote>
<h2 id="命名的基本标准"><a href="#命名的基本标准" class="headerlink" title="命名的基本标准"></a>命名的基本标准</h2><ul>
<li><p>类名使用小写字母，以中划线/下划线分隔</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>id采用驼峰式命名且尽量少用</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDialog"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>尽量不用拼音</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"pinyin"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>尽量不缩写，除非一看就能懂的单词</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fl"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>     //fr即float: right;</div></pre></td></tr></table></figure>
</li>
<li><p>禁用通配符，影响性能</p>
</li>
</ul>
<h2 id="CSS中的书写顺序"><a href="#CSS中的书写顺序" class="headerlink" title="CSS中的书写顺序"></a>CSS中的书写顺序</h2><ul>
<li>位置属性(position, display, float等)</li>
<li>大小(width, height, padding, margin)</li>
<li>文字系列(font系列, line-height, letter-spacing, color text-align等)</li>
<li>背景(background, border等)</li>
<li>其他(animation, transition等)</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.box&#123;</div><div class="line">  position:relative;</div><div class="line">  width:100px;</div><div class="line">  height:100px;</div><div class="line">  font-size:14px;</div><div class="line">  text-align:center;</div><div class="line">  background-color:#ccc;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="常用的class命名规范"><a href="#常用的class命名规范" class="headerlink" title="常用的class命名规范"></a>常用的class命名规范</h2><ul>
<li><p>页面结构区</p>
<p> 容器: container<br>　　页头：header<br>　　内容：content/container<br>　　页面主体：main<br>　　页尾：footer<br>　　导航：nav<br>　　侧栏：sidebar<br>　　栏目：column<br>　　页面外围控制整体佈局宽度：wrapper<br>　　左右中：left right center</p>
</li>
<li><p>导航</p>
<p> 导航：nav<br>　　主导航：mainnav<br>　　子导航：subnav<br>　　顶导航：topnav<br>　　边导航：sidebar<br>　　左导航：leftsidebar<br>　　右导航：rightsidebar<br>　　菜单：menu<br>　　子菜单：submenu<br>　　标题: title<br>　　摘要: summary</p>
</li>
<li><p>功能区</p>
<p> 标志：logo<br>　　广告：banner<br>　　登陆：login<br>　　登录条：loginbar<br>　　注册：register<br>　　搜索：search<br>　　功能区：shop<br>　　标题：title<br>　　加入：joinus<br>　　状态：status<br>　　按钮：btn<br>　　滚动：scroll<br>　　标籤页：tab<br>　　文章列表：list<br>　　提示信息：msg<br>　　当前的: current<br>　　小技巧：tips<br>　　图标: icon<br>　　注释：note<br>　　指南：guild<br>　　服务：service<br>　　热点：hot<br>　　新闻：news<br>　　下载：download<br>　　投票：vote<br>　　合作伙伴：partner<br>　　友情链接：link<br>　　版权：copyright</p>
</li>
<li><p>CSS样式表文件命名</p>
<p> 全局：global.css</p>
<p> 全局样式为全站公用，为页面样式基础，页面中必须包含。</p>
<p> 结构：layout.css</p>
<p> 页面结构类型复杂，并且公用类型较多时使用。多用在首页级页面和产品类页面中。</p>
<p> 私有：style.css</p>
<p> 独立页面所使用的样式文件，页面中必须包含。</p>
<p> 模块 module.css</p>
<p> 产品类页面应用，将可复用类模块进行剥离后，可与其它样式配合使用。</p>
<p> 主题 themes.css</p>
<p> 实现换肤功能时应用。</p>
<p> 补丁 mend.css</p>
</li>
</ul>
<pre><code>附图一张，加深记忆！
</code></pre><p><img src="http://i1.piimg.com/567571/4a295fce95d87fd6.png" alt="CSS命名"></p>
<h2 id="简单规则"><a href="#简单规则" class="headerlink" title="简单规则"></a>简单规则</h2><ul>
<li>以中划线连接，如.item-img</li>
<li>使用两个中划线表示特殊化，如.item-img.item-img–small表示在.item-img的基础上特殊化</li>
<li>状态类直接使用单词，参考上面的关键词，如.active, .checked</li>
<li>图标以icon-为前缀（字体图标采用.icon-font.i-name方式命名）。</li>
<li>模块采用关键词命名，如.slide, .modal, .tips, .-        tabs，特殊化采用上面两个中划线表示，如.imgslide–full, .modal–pay, .tips–up, .tabs–simple</li>
<li>js操作的类统一加上js-前缀</li>
<li>不要超过四个class组合使用，如.a.b.c.d</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>好了，以上就是常用的css命名规则了，其实说白了规则就是”人如其名”，稍微懂点英语就知道只不过就是把网页中相对应的地方以英文的方式来命名，毕竟我们都是用英文来写代码的！写代码其实也可以帮助提升自己的英语水平的，一举两得，何乐而不为呢？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来谈一谈我之前踩过的CSS坑之命名问题，相信很多跟我一样最开始学习CSS的时候都不知道怎样命名，有的起名字直接就是a，b，c，d（至少我初学的时候真的这么干过），更有甚者也会用汉语拼音来命名（例如这样：toubu，neirong，dibu等等），这些命名都是非常不好的习惯，在碰到很多复杂的页面布局时，这样命名会使自己不知所措，找一个class找很久都找不到，非常影响工（xue）作（xi）效率。
    
    </summary>
    
      <category term="html/css" scheme="https://tancky.github.io/categories/html-css/"/>
    
    
      <category term="css" scheme="https://tancky.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Sublime Text3中那些常用的快捷键</title>
    <link href="https://tancky.github.io/2016/12/13/Sublime-Text3%E4%B8%AD%E9%82%A3%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://tancky.github.io/2016/12/13/Sublime-Text3中那些常用的快捷键/</id>
    <published>2016-12-12T17:15:17.546Z</published>
    <updated>2016-12-12T17:24:02.258Z</updated>
    
    <content type="html"><![CDATA[<p>  学习前端时间也不短了，记得最开始学HTML/css的时候是通过《Head First HTML与CSS》这本书开始接触前端的，快递包裹拆开的时候整个人都懵逼了。好厚的一本书，整整700多页，对于我这种直到大学毕业了还没有好好的看过书的人来说简直是场灾难！不过幸好之前有在知乎了解到这本书虽然很厚，但是绝大部分都是以图文的形式展示出来的，所以看起来不会那么的吃力让人想睡觉。后来边看边跟着敲代码，当时的我还傻不拉几的用的windows系统自带的记事本，每天重复得敲着<html><head></head></html>…等等，竟然没有很厌烦的感觉，反而乐此不疲，也许这就是在自学前端的过程中所能给我带来的最大的快乐吧，看到自己敲的代码在浏览器中呈现出来，那种感觉只有亲身经历过才会懂！</p>
<p>直到我接触了sublime Text编辑器也就是今天这篇文章的重点，我就深深的爱上了他！<a id="more"></a>熟练掌握各种快捷键，可以给我们日常工作中带来极大的便利，节约时间成本，把精力专心地放在项目上。那么首先我们来看看他有哪些优点！</p>
<blockquote>
<p>Sublime Text：一款具有代码高亮、语法提示、自动完成且反应快速的编辑器软件，不仅具有华丽的界面，还支持插件扩展机制，用她来写代码，绝对是一种享受。相比于难于上手的Vim，浮肿沉重的Eclipse，VS，即便体积轻巧迅速启动的Editplus、Notepad++，在SublimeText面前大略显失色，无疑这款性感无比的编辑器是Coding和Writing最佳的选择，没有之一。</p>
</blockquote>
<h2 id="最常用的快捷键（以windows系统为例）"><a href="#最常用的快捷键（以windows系统为例）" class="headerlink" title="最常用的快捷键（以windows系统为例）"></a>最常用的快捷键（以windows系统为例）</h2><h3 id="命令面板"><a href="#命令面板" class="headerlink" title="命令面板"></a>命令面板</h3><ul>
<li>双击界面后按下Ctrl+shift+p即可调用命令面板像这样</li>
</ul>
<p><img src="http://i1.piimg.com/567571/90259d0897d885ba.png" alt="命令面板"></p>
<ul>
<li>我们可以输入Package Control安装各种插件  【首推Emmet插件】(PS:sublime text编辑器支持模糊匹配，例如输入Package Control，那么只需要输入pctl即可匹配到该命令，如下图所示)</li>
</ul>
<p><img src="http://i1.piimg.com/567571/1ae879010b551e56.png" alt="命令面板">        </p>
<ul>
<li>也可以输入html，css，JavaScript等来改变要使用的语言环境</li>
</ul>
<p><img src="http://i1.piimg.com/567571/4e6777f367263ad8.png" alt="命令面板">    </p>
<h3 id="多行游标"><a href="#多行游标" class="headerlink" title="多行游标"></a>多行游标</h3><ul>
<li><p>Ctrl+H：查找替换</p>
</li>
<li><p>Ctrl+D 选词 （选中某个文本后，反复按快捷键即可选中下一个相同的文本同时编辑）</p>
</li>
<li><p>Ctrl+K Ctrl+D 跳过当前选择，选择下一个</p>
</li>
<li><p>Alt+F3 选择所有与光标所在单词相同的单词</p>
</li>
<li><p>按住shift键，然后按住鼠标右键向下拖动，也可产生多行游标</p>
</li>
</ul>
<p><img src="http://p1.bpimg.com/567571/3db00a73f0251227.png" alt="命令面板"> </p>
<pre><code>第二个图为连续按了5次Ctrl+D后的结果， 也可以直接按Alt+F3！
</code></pre><p><img src="http://p1.bpimg.com/567571/50f2bb5cf95611f1.png" alt="命令面板"></p>
<h3 id="搜索，撤销，反撤销"><a href="#搜索，撤销，反撤销" class="headerlink" title="搜索，撤销，反撤销"></a>搜索，撤销，反撤销</h3><ul>
<li>Ctrl+F 搜索 （搜索当前文档中相对应的字符串，搜索到的字符串以高亮显示）</li>
</ul>
<p><img src="http://p1.bpimg.com/567571/d67923e3b1cbcdff.png" alt="命令面板"> </p>
<ul>
<li>Ctrl+Z 撤销 （撤销上一步的操作，可重复按键）</li>
</ul>
<ul>
<li>Ctrl+Y 取消撤销（与之相反）</li>
</ul>
<p><img src="http://p1.bpimg.com/567571/046f325568dd5853.png" alt="命令面板"> </p>
<pre><code>按下Crtl+Z后
</code></pre><p><img src="http://p1.bpimg.com/567571/1fd1819f78ae94b4.png" alt="命令面板"> </p>
<h3 id="标签页切换"><a href="#标签页切换" class="headerlink" title="标签页切换"></a>标签页切换</h3><ul>
<li>Ctrl+Tab （当前窗口中的标签页切换）</li>
</ul>
<p><img src="http://p1.bqimg.com/567571/5956d7336b9b60f2.png" alt="命令面板"> </p>
<pre><code>切换后效果   
</code></pre><p><img src="http://p1.bqimg.com/567571/906b7f5ebb6e0813.png" alt="命令面板"> </p>
<h3 id="删除整行"><a href="#删除整行" class="headerlink" title="删除整行"></a>删除整行</h3><ul>
<li>Ctrl+Shift+K （删除整行）</li>
</ul>
<p><img src="http://p1.bqimg.com/567571/c578a0f4ab4d93e2.png" alt="命令面板"> </p>
<pre><code>删除后效果   
</code></pre><p><img src="http://p1.bqimg.com/567571/2265fe38920c723c.png" alt="命令面板"> </p>
<h2 id="学以致用"><a href="#学以致用" class="headerlink" title="学以致用"></a>学以致用</h2><h3 id="如何快速搭建一个HTML文档"><a href="#如何快速搭建一个HTML文档" class="headerlink" title="如何快速搭建一个HTML文档"></a>如何快速搭建一个HTML文档</h3><ul>
<li><p>Ctrl+N </p>
</li>
<li><p>Ctrl+S   保存页面<br><img src="http://p1.bqimg.com/567571/44936a881c3538af.png" alt="命令面板"></p>
</li>
</ul>
<ul>
<li>Ctrl+shift+p  调用命令面板输入，输入HTML调用语言</li>
</ul>
<p><img src="http://i1.piimg.com/567571/50a48a9b34374fc3.png" alt="命令面板"></p>
<ul>
<li>编辑区输入！号</li>
</ul>
<p><img src="http://i1.piimg.com/567571/97155fb46a7cfdfb.png" alt="命令面板"></p>
<ul>
<li>Ctrl+E </li>
</ul>
<p><img src="http://i1.piimg.com/567571/d93d37845fda2ef9.png" alt="命令面板"></p>
<ul>
<li>Ctrl+P 输入#body回车即可跳转至body标签 </li>
</ul>
<p><img src="http://i1.piimg.com/567571/6e621d3ad422c47b.png" alt="命令面板"></p>
<p><img src="http://i1.piimg.com/567571/1ca8efa598e2d074.png" alt="命令面板"></p>
<ul>
<li><p>Ctrl+Enter 在当前行下添加一行 </p>
</li>
<li><p>ctrl+shirt+enter 在当前行上方添加一行（与之相反）</p>
</li>
</ul>
<p><img src="http://i1.piimg.com/567571/2f728a1ca18eba45.png" alt="命令面板"></p>
<ul>
<li>(ul&gt;.item \$*10{content} )   （ &gt; 号生成子元素 ，\$ 产生序号，{ }产生内容 ）</li>
</ul>
<p><img src="http://i1.piimg.com/567571/db6d17920f20c790.png" alt="命令面板"></p>
<ul>
<li>Ctrl+E </li>
</ul>
<p><img src="http://i1.piimg.com/567571/056f235dfff6c6eb.png" alt="命令面板"></p>
<ul>
<li><p>Ctrl+] 增加缩进 </p>
</li>
<li><p>Ctrl+[ 减小缩进</p>
</li>
</ul>
<p><img src="http://i1.piimg.com/567571/fc1c6e3b10018421.png" alt="命令面板"></p>
<ul>
<li>光标点击需要多选的位置</li>
</ul>
<p><img src="http://p1.bqimg.com/567571/8fd0f3152d2abd5c.png" alt="命令面板"></p>
<ul>
<li>Alt+F3  全选</li>
</ul>
<p><img src="http://p1.bqimg.com/567571/0944cf6800892e76.png" alt="命令面板"></p>
<ul>
<li>输入h3{}，然后Ctrl+E（注：Ctrl+E也可以用来闭合元素标签）</li>
</ul>
<p><img src="http://p1.bqimg.com/567571/ff68d5f0f59d03ed.png" alt="命令面板"></p>
<p><img src="http://p1.bqimg.com/567571/56a0a1aa9a8c1e28.png" alt="命令面板"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>好了，以上就是在开发过程中常见的一些快捷键，希望可以通过图文并茂的方式可以更好的帮助记忆（PS：受head first 系列图书的影响…），其实这里面也有很多我自己也没用过的快捷键，以后没事儿的时候多来看看，再敲代码的时候就可以更轻松了哈哈哈，这样极大限度的摆脱鼠标的困扰，两耳不闻窗外事，一心只去敲代码！<br>Fighting！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  学习前端时间也不短了，记得最开始学HTML/css的时候是通过《Head First HTML与CSS》这本书开始接触前端的，快递包裹拆开的时候整个人都懵逼了。好厚的一本书，整整700多页，对于我这种直到大学毕业了还没有好好的看过书的人来说简直是场灾难！不过幸好之前有在知乎了解到这本书虽然很厚，但是绝大部分都是以图文的形式展示出来的，所以看起来不会那么的吃力让人想睡觉。后来边看边跟着敲代码，当时的我还傻不拉几的用的windows系统自带的记事本，每天重复得敲着&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;/html&gt;…等等，竟然没有很厌烦的感觉，反而乐此不疲，也许这就是在自学前端的过程中所能给我带来的最大的快乐吧，看到自己敲的代码在浏览器中呈现出来，那种感觉只有亲身经历过才会懂！&lt;/p&gt;
&lt;p&gt;直到我接触了sublime Text编辑器也就是今天这篇文章的重点，我就深深的爱上了他！
    
    </summary>
    
      <category term="Sublime Text" scheme="https://tancky.github.io/categories/Sublime-Text/"/>
    
    
      <category term="Sublime Text" scheme="https://tancky.github.io/tags/Sublime-Text/"/>
    
  </entry>
  
</feed>
