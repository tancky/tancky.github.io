<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Vue-cli#2.0项目结构分析]]></title>
      <url>%2F2017%2F06%2F26%2FVue-cli-2-0%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[Vue-cli#2.0项目结构分析最近在学习Vue.js框架，正打算做一个小项目练练手。第一步当然少不了强大的Vue-cli脚手架工具。那么什么是Vue-cli呢？ Vue-cli是vue官方出品的快速构建单页应用的脚手架，他可以快速的帮你构建一个强大的Vue.js项目。 一. 安装Vue-cli1npm install vue-cli -g -g :代表全局安装。如果你安装时报错，一般是网络问题，你可以尝试用cnpm来进行安装。安装完成后，可以用vue -V来进行查看 vue-cli的版本号。注意这里的V是大写的。我这里版本号是2.8.1. 如果vue -V的命令管用了，说明已经顺利的把vue-cli安装到我们的计算机里了。 二. 初始化项目我们用vue init命令来初始化项目，具体看一下这条命令的使用方法。 1$ vue init &lt;template-name&gt; &lt;project-name&gt; init：表示我要用vue-cli来初始化项目 template-name：表示模板名称，vue-cli官方为我们提供了5种模板， webpack-一个全面的webpack+vue-loader的模板，功能包括热加载，linting,检测和CSS扩展。 webpack-simple-一个简单webpack+vue-loader的模板，不包含其他功能，让你快速的搭建vue的开发环境。 browserify-一个全面的Browserify+vueify 的模板，功能包括热加载，linting,单元检测。 browserify-simple-一个简单Browserify+vueify的模板，不包含其他功能，让你快速的搭建vue的开发环境。 simple-一个最简单的单页应用模板。 project-name：标识项目名称，这个你可以根据自己的项目来起名字。 在实际开发中，一般我们都会使用webpack这个模板，那我们这里也安装这个模板，在命令行输入以下命令： 1vue init webpack vuecliTest 输入命令后，会询问我们几个简单的选项，我们根据自己的需要进行填写就可以了。 Project name :项目名称 ，如果不需要更改直接回车就可以了。注意：这里不能使用大写，所以我把名称改成了vueclitest Project description:项目描述，默认为A Vue.js project,直接回车，不用编写。 Author：作者，如果你有配置git的作者，他会读取。 Install vue-router? 是否安装vue的路由插件，我们这里需要安装，所以选择Y Use ESLint to lint your code? 是否用ESLint来限制你的代码错误和风格。我们这里不需要输入n，如果你是大型团队开发，最好是进行配置。setup unit tests with Karma + Mocha? 是否需要安装单元测试工具Karma+Mocha，我们这里不需要，所以输入n。 Setup e2e tests with Nightwatch?是否安装e2e来进行用户行为模拟测试，我们这里不需要，所以输入n。命令行出现上面的文字，说明我们已经初始化好了第一步。命令行提示我们现在可以作的三件事情。 1、cd vuecliTest 进入我们的vue项目目录。 2、npm install 安装我们的项目依赖包，也就是安装package.json里的包，如果你网速不好，你也可以使用cnpm来安装。 3、npm run dev 开发模式下运行我们的程序。给我们自动构建了开发用的服务器环境和在浏览器中打开，并实时监视我们的代码更改，即时呈现给我们。 三.Vue-cli项目结构分析vue-cli脚手架工具就是为我们搭建了开发所需要的环境，为我们省去了很多精力。有必要对这个环境进行熟悉，我们就从项目的结构讲起。 1234567891011121314151617181920212223242526272829|-- build // 项目构建(webpack)相关代码| |-- build.js // 生产环境构建代码| |-- check-version.js // 检查node、npm等版本| |-- dev-client.js // 热重载相关| |-- dev-server.js // 构建本地服务器| |-- utils.js // 构建工具相关| |-- webpack.base.conf.js // webpack基础配置| |-- webpack.dev.conf.js // webpack开发环境配置| |-- webpack.prod.conf.js // webpack生产环境配置|-- config // 项目开发环境配置| |-- dev.env.js // 开发环境变量| |-- index.js // 项目一些配置变量| |-- prod.env.js // 生产环境变量| |-- test.env.js // 测试环境变量|-- src // 源码目录| |-- components // vue公共组件| |-- store // vuex的状态管理| |-- App.vue // 页面入口文件| |-- main.js // 程序入口文件，加载各种公共组件|-- static // 静态文件，比如一些图片，json数据等| |-- data // 群聊分析得到的数据用于数据可视化|-- .babelrc // ES6语法编译配置|-- .editorconfig // 定义代码格式|-- .gitignore // git上传需要忽略的文件格式|-- README.md // 项目说明|-- favicon.ico |-- index.html // 入口页面|-- package.json // 项目基本信息. 1.Package.jsonpackage.json文件是项目根目录下的一个文件，定义该项目开发所需要的各种模块以及一些项目配置信息（如项目名称、版本、描述、作者等）。 package.json 里的scripts字段，这个字段定义了你可以用npm运行的命令。在开发环境下，在命令行工具中运行npm run dev 就相当于执行 node build/dev-server.js .也就是开启了一个node写的开发行建议服务器。由此可以看出script字段是用来指定npm相关命令的缩写。 1234"scripts": &#123; "dev": "node build/dev-server.js", "build": "node build/build.js" &#125;, 2.dependencies字段和devDependencies字段 dependencies字段指项目运行时所依赖的模块； devDependencies字段指定了项目开发时所依赖的模块； 在命令行中运行npm install命令，会自动安装dependencies和devDempendencies字段中的模块。package.json还有很多相关配置，如果你想全面了解，可以专门去百度学习一下。 3.Webpack相关我们在上面说了运行npm run dev 就相当于执行了node build/dev-server.js,说明这个文件相当重要，先来熟悉一下它。 我贴出代码并给出重要的解释。 1).dev-server.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109// 检查 Node 和 npm 版本require('./check-versions')()// 获取 config/index.js 的默认配置var config = require('../config')// 如果 Node 的环境无法判断当前是 dev / product 环境// 使用 config.dev.env.NODE_ENV 作为当前的环境if (!process.env.NODE_ENV) process.env.NODE_ENV = JSON.parse(config.dev.env.NODE_ENV)// 使用 NodeJS 自带的文件路径工具var path = require('path')// 使用 expressvar express = require('express')// 使用 webpackvar webpack = require('webpack')// 一个可以强制打开浏览器并跳转到指定 url 的插件var opn = require('opn')// 使用 proxyTablevar proxyMiddleware = require('http-proxy-middleware')// 使用 dev 环境的 webpack 配置var webpackConfig = require('./webpack.dev.conf')// default port where dev server listens for incoming traffic// 如果没有指定运行端口，使用 config.dev.port 作为运行端口var port = process.env.PORT || config.dev.port// Define HTTP proxies to your custom API backend// https://github.com/chimurai/http-proxy-middleware// 使用 config.dev.proxyTable 的配置作为 proxyTable 的代理配置var proxyTable = config.dev.proxyTable// 使用 express 启动一个服务var app = express()// 启动 webpack 进行编译var compiler = webpack(webpackConfig)// 启动 webpack-dev-middleware，将 编译后的文件暂存到内存中var devMiddleware = require('webpack-dev-middleware')(compiler, &#123; publicPath: webpackConfig.output.publicPath, stats: &#123; colors: true, chunks: false &#125;&#125;)// 启动 webpack-hot-middleware，也就是我们常说的 Hot-reloadvar hotMiddleware = require('webpack-hot-middleware')(compiler)// force page reload when html-webpack-plugin template changescompiler.plugin('compilation', function (compilation) &#123; compilation.plugin('html-webpack-plugin-after-emit', function (data, cb) &#123; hotMiddleware.publish(&#123; action: 'reload' &#125;) cb() &#125;)&#125;)// proxy api requests// 将 proxyTable 中的请求配置挂在到启动的 express 服务上Object.keys(proxyTable).forEach(function (context) &#123; var options = proxyTable[context] if (typeof options === 'string') &#123; options = &#123; target: options &#125; &#125; app.use(proxyMiddleware(context, options))&#125;)// handle fallback for HTML5 history API// 使用 connect-history-api-fallback 匹配资源，如果不匹配就可以重定向到指定地址app.use(require('connect-history-api-fallback')())// serve webpack bundle output// 将暂存到内存中的 webpack 编译后的文件挂在到 express 服务上app.use(devMiddleware)// enable hot-reload and state-preserving// compilation error display// 将 Hot-reload 挂在到 express 服务上app.use(hotMiddleware)// serve pure static assets// 拼接 static 文件夹的静态资源路径var staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)// 为静态资源提供响应服务app.use(staticPath, express.static('./static'))// 让我们这个 express 服务监听 port 的请求，并且将此服务作为 dev-server.js 的接口暴露module.exports = app.listen(port, function (err) &#123; if (err) &#123; console.log(err) return &#125; var uri = 'http://localhost:' + port console.log('Listening at ' + uri + '\n') // when env is testing, don't need open it // 如果不是测试环境，自动打开浏览器并跳到我们的开发地址 if (process.env.NODE_ENV !== 'testing') &#123; opn(uri) &#125;&#125;) 2).webpack.base.confg.js webpack的基础配置文件123456789101112131415161718192021222324252627282930......module.export = &#123; // 编译入口文件 entry: &#123;&#125;, // 编译输出路径 output: &#123;&#125;, // 一些解决方案配置 resolve: &#123;&#125;, resolveLoader: &#123;&#125;, module: &#123; // 各种不同类型文件加载器配置 loaders: &#123; ... ... // js文件用babel转码 &#123; test: /\.js$/, loader: 'babel', include: projectRoot, // 哪些文件不需要转码 exclude: /node_modules/ &#125;, ... ... &#125; &#125;, // vue文件一些相关配置 vue: &#123;&#125;&#125; 3). .babelrcBabel解释器的配置文件，存放在根目录下。Babel是一个转码器，项目里需要用它将ES6代码转为ES5代码。如果你想了解更多，可以查看babel的知识。 1234567891011121314151617&#123; //设定转码规则 "presets": [ ["env", &#123; "modules": false &#125;], "stage-2" ], //转码用的插件 "plugins": ["transform-runtime"], "comments": false, //对BABEL_ENV或者NODE_ENV指定的不同的环境变量，进行不同的编译操作 "env": &#123; "test": &#123; "presets": ["env", "stage-2"], "plugins": [ "istanbul" ] &#125; &#125;&#125; 4). .editorconfig该文件定义项目的编码规范，编译器的行为会与.editorconfig文件中定义的一致，并且其优先级比编译器自身的设置要高，这在多人合作开发项目时十分有用而且必要。123456789root = true[*] // 对所有文件应用下面的规则charset = utf-8 // 编码规则用utf-8indent_style = space // 缩进用空格indent_size = 2 // 缩进数量为2个空格end_of_line = lf // 换行符格式insert_final_newline = true // 是否在文件的最后插入一个空行trim_trailing_whitespace = true // 是否删除行尾的空格 四. Vue-cli模板1、npm run build 命令我们在命令行中输入npm run build命令后，vue-cli会自动进行项目发布打包。你在package.json文件的scripts字段中可以看出，你执行的npm run build命令就相对执行的 node build/build.js 。 package.json的scripts 字段：1234"scripts": &#123; "dev": "node build/dev-server.js", "build": "node build/build.js"&#125;, 在执行完npm run build命令后，在你的项目根目录生成了dist文件夹，这个文件夹里边就是我们要传到服务器上的文件。 dist文件夹下目录包括： index.html 主页文件:因为我们开发的是单页web应用，所以说一般只有一个html文件。 static 静态资源文件夹：里边js、CSS和一些图片。 2、main.js文件解读main.js是整个项目的入口文件,在src文件夹下： 12345678910111213import Vue from 'vue' import App from './App'import router from './router'Vue.config.productionTip = false //生产环境提示，这里设置成了false/* eslint-disable no-new */new Vue(&#123; el: '#app', router, template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) 通过代码可以看出这里引进了App的组件和的模板，它是通过 import App from ‘./App’这句代码引入的。 我们找到App.vue文件，打开查看。 3、App.vue文件:1234567891011121314151617181920212223&lt;template&gt; &lt;div id="app"&gt; &lt;img src="./assets/logo.png"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'app'&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; app.vue文件我们可以分成三部分解读， 标签包裹的内容：这是模板的HTMLDom结构，里边引入了一张图片和标签，标签说明使用了路由机制。我们会在以后专门拿出一篇文章讲Vue-router。 标签包括的js内容：你可以在这里些一些页面的动态效果和Vue的逻辑代码。 标签包裹的css内容：这里就是你平时写的CSS样式，对页面样子进行装饰用的，需要特别说明的是你可以用来声明这些css样式只在本模板中起作用。 4、router/index.js 路由文件引文在app.vue中我们看到了路由文件，虽然router的内容比较多，但是我们先简单的看一下。下篇文章我们就开始讲Vue-router。 123456789101112131415import Vue from 'vue'import Router from 'vue-router'import Hello from '@/components/Hello'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'Hello', component: Hello &#125; ]&#125;) 我们可以看到 import Hello from ‘@/components/Hello’这句话， 文件引入了/components/Hello.vue文件。这个文件里就配置了一个路由，就是当我们访问网站时给我们显示Hello.vue的内容。 5、Hello.vue文件解读：这个文件就是我们在第一节课看到的页面文件了。也是分为三个部分，以后我们大部分的工作都是写这些.vue结尾的文件。现在我们可以试着改一些内容，然后预览一下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template&gt; &lt;div class="hello"&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;h2&gt;Essential Links&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://vuejs.org" target="_blank"&gt;Core Docs&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://forum.vuejs.org" target="_blank"&gt;Forum&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://gitter.im/vuejs/vue" target="_blank"&gt;Gitter Chat&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://twitter.com/vuejs" target="_blank"&gt;Twitter&lt;/a&gt;&lt;/li&gt; &lt;br&gt; &lt;li&gt;&lt;a href="http://vuejs-templates.github.io/webpack/" target="_blank"&gt;Docs for This Template&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;Ecosystem&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="http://router.vuejs.org/" target="_blank"&gt;vue-router&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="http://vuex.vuejs.org/" target="_blank"&gt;vuex&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="http://vue-loader.vuejs.org/" target="_blank"&gt;vue-loader&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://github.com/vuejs/awesome-vue" target="_blank"&gt;awesome-vue&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'hello', data () &#123; return &#123; msg: 'Welcome to Your Vue.js App' &#125; &#125;&#125;&lt;/script&gt;&lt;!-- Add "scoped" attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;h1, h2 &#123; font-weight: normal;&#125;ul &#123; list-style-type: none; padding: 0;&#125;li &#123; display: inline-block; margin: 0 10px;&#125;a &#123; color: #42b983;&#125;&lt;/style&gt; 五. 总结以上就是有关Vue-cli项目结构的所有分析了，俗话说得好：赢在起跑线上才是最重要的。了解清楚了脚手架的项目结构，以后撸代码思路就会很清晰，少走很多弯路，与君共勉。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTPS原理详解]]></title>
      <url>%2F2017%2F06%2F18%2FHTTPS%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[HTTPS（全称：HyperText Transfer Protocol over Secure Socket Layer），其实 HTTPS 并不是一个新鲜协议，Google 很早就开始启用了，初衷是为了保证数据安全。 近两年，Google、Baidu、Facebook 等这样的互联网巨头，不谋而合地开始大力推行 HTTPS， 国内外的大型互联网公司很多也都已经启用了全站 HTTPS，这也是未来互联网发展的趋势。 为鼓励全球网站的 HTTPS 实现，一些互联网公司都提出了自己的要求： 1）Google 已调整搜索引擎算法，让采用 HTTPS 的网站在搜索中排名更靠前； 2）从 2017 年开始，Chrome 浏览器已把采用 HTTP 协议的网站标记为不安全网站； 3）苹果要求 2017 年 App Store 中的所有应用都必须使用 HTTPS 加密连接； 4）当前国内炒的很火热的微信小程序也要求必须使用 HTTPS 协议； 5）新一代的 HTTP/2 协议的支持需以 HTTPS 为基础。 等等，因此想必在不久的将来，全网 HTTPS 势在必行。 概念协议1、HTTP 协议（HyperText Transfer Protocol，超文本传输协议）：是客户端浏览器或其他程序与Web服务器之间的应用层通信协议 。 2、HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输。 HTTPS 相比 HTTP 多了一层 SSL/TLS SSL（Secure Socket Layer，安全套接字层）：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。 TLS（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。 加密算法：据记载，公元前400年，古希腊人就发明了置换密码；在第二次世界大战期间，德国军方启用了“恩尼格玛”密码机，所以密码学在社会发展中有着广泛的用途。 1、对称加密有流式、分组两种，加密和解密都是使用的同一个密钥。 例如：DES、AES-GCM、ChaCha20-Poly1305等 2、非对称加密加密使用的密钥和解密使用的密钥是不相同的，分别称为：公钥、私钥，公钥和算法都是公开的，私钥是保密的。非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。 例如：RSA、DSA、ECDSA、 DH、ECDHE 3、哈希算法将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。 例如：MD5、SHA-1、SHA-2、SHA-256 等 4、数字签名签名就是在信息的后面再加上一段内容（信息经过hash后的值），可以证明信息没有被修改过。hash值一般都会加密后（也就是签名）再和信息一起发送，以保证这个hash值不被修改。 详解一、HTTP 访问过程 抓包如下： 如上图所示，HTTP请求过程中，客户端与服务器之间没有任何身份确认的过程，数据全部明文传输，“裸奔”在互联网上，所以很容易遭到黑客的攻击，如下： 可以看到，客户端发出的请求很容易被黑客截获，如果此时黑客冒充服务器，则其可返回任意信息给客户端，而不被客户端察觉，所以我们经常会听到一词“劫持”，现象如下： 下面两图中，浏览器中填入的是相同的URL，左边是正确响应，而右边则是被劫持后的响应 所以 HTTP 传输面临的风险有： （1） 窃听风险：黑客可以获知通信内容。 （2） 篡改风险：黑客可以修改通信内容。 （3） 冒充风险：黑客可以冒充他人身份参与通信。 二、HTTP 向 HTTPS 演化的过程第一步：为了防止上述现象的发生，人们想到一个办法：对传输的信息加密（即使黑客截获，也无法破解） 如上图所示，此种方式属于对称加密，双方拥有相同的密钥，信息得到安全传输，但此种方式的缺点是： （1）不同的客户端、服务器数量庞大，所以双方都需要维护大量的密钥，维护成本很高 （2）因每个客户端、服务器的安全级别不同，密钥极易泄露 第二步：既然使用对称加密时，密钥维护这么繁琐，那我们就用非对称加密试试 如上图所示，客户端用公钥对请求内容加密，服务器使用私钥对内容解密，反之亦然，但上述过程也存在缺点： （1）公钥是公开的（也就是黑客也会有公钥），所以第 ④ 步私钥加密的信息，如果被黑客截获，其可以使用公钥进行解密，获取其中的内容 第三步：非对称加密既然也有缺陷，那我们就将对称加密，非对称加密两者结合起来，取其精华、去其糟粕，发挥两者的各自的优势 如上图所示 （1）第 ③ 步时，客户端说：（咱们后续回话采用对称加密吧，这是对称加密的算法和对称密钥）这段话用公钥进行加密，然后传给服务器 （2）服务器收到信息后，用私钥解密，提取出对称加密算法和对称密钥后，服务器说：（好的）对称密钥加密 （3）后续两者之间信息的传输就可以使用对称加密的方式了 遇到的问题： （1）客户端如何获得公钥 （2）如何确认服务器是真实的而不是黑客 第四步：获取公钥与确认服务器身份 1、获取公钥（1）提供一个下载公钥的地址，回话前让客户端去下载。（缺点：下载地址有可能是假的；客户端每次在回话前都先去下载公钥也很麻烦）（2）回话开始时，服务器把公钥发给客户端（缺点：黑客冒充服务器，发送给客户端假的公钥） 2、那有木有一种方式既可以安全的获取公钥，又能防止黑客冒充呢？ 那就需要用到终极武器了：SSL 证书（申购） 如上图所示，在第 ② 步时服务器发送了一个SSL证书给客户端，SSL 证书中包含的具体内容有： （1）证书的发布机构CA （2）证书的有效期 （3）公钥 （4）证书所有者 （5）签名 ……… 3、客户端在接受到服务端发来的SSL证书时，会对证书的真伪进行校验，以浏览器为例说明如下：（1）首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验 （2）浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发 （3）如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。 （4）如果找到，那么浏览器就会从操作系统中取出 颁发者CA 的公钥，然后对服务器发来的证书里面的签名进行解密 （5）浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比 （6）对比结果一致，则证明服务器发来的证书合法，没有被冒充 （7）此时浏览器就可以读取证书中的公钥，用于后续加密了 4、所以通过发送SSL证书的形式，既解决了公钥获取问题，又解决了黑客冒充问题，一箭双雕，HTTPS加密过程也就此形成所以相比HTTP，HTTPS 传输更加安全 （1） 所有信息都是加密传播，黑客无法窃听。 （2） 具有校验机制，一旦被篡改，通信双方会立刻发现。 （3） 配备身份证书，防止身份被冒充。 总结综上所述，相比 HTTP 协议，HTTPS 协议增加了很多握手、加密解密等流程，虽然过程很复杂，但其可以保证数据传输的安全。所以在这个互联网膨胀的时代，其中隐藏着各种看不见的危机，为了保证数据的安全，维护网络稳定，建议大家多多推广HTTPS。 原文转自https://segmentfault.com/p/1210000009779379]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[理解JavaScript中的事件委托]]></title>
      <url>%2F2016%2F12%2F21%2F%E7%90%86%E8%A7%A3JavaScript%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%2F</url>
      <content type="text"><![CDATA[在我们平常工作或学习编写JS代码的过程中，经常会做的一件事就是给某个元素绑定事件。例如鼠标点击，移入，移出等等，以响应用户的某种行为，举个栗子：1234var btn=document.getElementById("btn"); btn.onclick=function()&#123; alert("hello world!"); &#125;; 上述的栗子是当用户点击某个按钮时会弹出对话框显示”hello world” 。但是在某些情况下，我们期望页面上的一些元素响应用户同样的动作，举个例子。在用户点击列表的每一项时，将其内容显示在div里。例如这样：12345678910&lt;ul class="list"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; … &lt;li&gt;100&lt;/li&gt;&lt;/ul&gt;&lt;div class="list-show"&gt;&lt;/div&gt; 用JQuery我们可以这么做：123$('.list li').on('click', function() &#123; $('.list-show').html($(this).html());&#125;); 其实就是给列表的每一项（100个）分别绑定了点击事件。这样做的弊端在于，增加了内存，因为\$(.list li)里有100个li对象。同时降低了代码性能，因为$(’.list li’)会搜索ul下所有的li元素。 那么有没有更好的方法呢？当然有，那就是事件委托！上面代码也可以这样写：123$('.list').on('click', 'li', function() &#123; $('.list-show').html($(this).html());&#125;); //jquery都是用on绑定事件。jquery规定on()中的第二个参数如果是dom元素，则为事件委托，否则为正常的事件绑定。 基本概念 什么是事件委托事件委托又称事件代理（话说之前我以为这两个是不一样的概念…），用网上很经典的一个场景来描述就是取快递： 有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。 这里其实还有2层意思的： 第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的； 第二，新员工也是可以被前台MM代为签收的，即程序中新添加的dom节点也是有事件的。 事件委托的原理 事件委托其实就是利用的事件冒泡的原理，而事件冒泡就是事件开始时由最具体的元素（文档中嵌套层次最深的那个节点接收），然后逐级向上传播到最不为具体的节点（文档）。 在本文最开始举例的代码中可以看出： 将li元素的点击事件委托给其父元素ul。这么做之所以行得通，是因为事件具有冒泡的特点，当内层元素的某个事件被触发，事件会一级一级冒泡到更外层元素。当外层元素被绑定事件且被触发时，判断事件的来源即event.target是否是目标元素li，如果是就执行回调。上面的代码等价于： 12345678910function showText(text) &#123; $('.list-show').html(text);&#125;$('.list').on('click', function(event) &#123; var $target = $(event.target); if ($target.is('li')) &#123; showText($target.html()); &#125;&#125;); 事件委托的优点 A.使用事件委托可以明显减少dom的操作次数，优化性能和节约内存空间。B.新添加的元素依然会有之前添加的事件（即新来的员工也能收到快递）。在上例中，如果通过AJAX向列表增加新项，新添加项仍能响应用户点击。在页面动态变化后，不需要重新检索元素和绑定事件。 本文完！ 撒花！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript中的数据类型]]></title>
      <url>%2F2016%2F12%2F17%2FJavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[今天继续夯实基础，写一写Js中的数据类型，理清楚概念才能少踩一些没必要的坑，特别是对于很多初学者而言（好吧，包括我在内）很容易弄混淆的东西。 两类数据类型众所周知，JS中有六种数据类型，按全球JS顶尖专家Nicholas Zakas的说法，JS中数据类型又分成两大类：第一种是简单的数据类型（原始类型）：Undefined,Null,Boolean,Number以及String，其二是复杂的数据类型（引用类型）——object，而object本质上是由一组无序的名值对组成的。在ECMAScript中不支持任何创建自定义类型的机制，所有的值最终都将是上述的6种数据类型之一。123456789var a=100; //此时a为number类型a=true; //此时a为boolean类型a="Hello,JavaScript!"; //此时a为string类型a=&#123;&#125;; //此时a为object类型a=function()&#123;&#125; //此时a为function类型,也是属于对象类型 typeof操作符由于JS是一种弱类型的编程语言，所以需要有一种手段来检测给定变量的数据类型——typeof操作符。举个栗子：1234var msg="Hello World"alert(typeof msg); //"string"alert(typeof(msg)); //"string"alert(typeof 37); //"number" 原始类型 Undefined类型 Undefined类型只有一个值叫—不存在！这个不存在在JS中就是undefined, 就是英文的原意：『未定义』，但我总觉得这个文绉绉的词其实不好理解。不如把它理解为不存在更然人明白些。在使用var 声明变量但没有初始化的时候，这个变量的值就是undefined。再举个栗子： 12var msg；alert(msg == undefined); //true; A. 如果一个函数没有返回值，其实就是它的返回值为undefined,即它的返回值不存在。B. 访问一个对象所没有的属性？对不起，得到的是undefined, 即这个属性不存在。C. 代码中写了：var a; console.log(a); 得到undefined, 即这个a不存在，你会争辩：可我明明写了var a;a在我的代码中啊，对的！但这就好比我们人类在这个世界可以把那些没法证实已经存在的东西专门起个名字–叫『不存在』一样。你可以提到它，但它真的不存在。它的名字就叫：不存在。 Null类型 之前看过一个大神的文章里面，他是这么来谈null类型的: 很多书上喜欢把程序中的变量比喻成一个盒子，里面装的内容就是变量的值。盒子中装的内容是可以变化的，所以叫变量。这个比喻很形象。先赞一下。 如果你送个你女朋友一个礼物盒，里面装得有礼物，用JS的话来说，你给了她一个变量（因为下次你可能用同样的礼物盒子，但装另外的礼物），如果你只是给了她一个空盒子，用JS的话来比喻，你给了她一个空值，就是null,里面什么也没有装（当然你会被她痛扁的），但这个盒子是存在的，不是undefined的。 但这个空盒子的类型是什么？typeof(null), 返回居然是’object’, 它是对象类型？它不是原始类型？它居然是引用类型？有没有搞错？是的，但不是我们搞错了，是JS的设计者搞错了，但他就是这么设计的。 由于JS是一个外国大牛仅仅花了十天的时间便创造出来的一门编程语言,现在已经发展到满世界这么流行了，此人已经灰常牛了，如果他不犯一点点错误，还叫我们这样智力平平但又靠写代码为生的码农怎么混？还要不要我们活了？他犯错了，说明他是人，不是神！ 虽然很多书中把null叫做空对象, 但按照Nicholas Zakas这样全球顶尖JS高手的归类，它不是引用类型，它应该归于原始类型，只是它是一种特殊的原始类型，尽管typeof(null)返回’object’。 Boolean类型 Boolean类型（又叫布尔类型）是JS种使用的最多的一种数据类型。他只会返回两个值（布尔值）：ture或者false，且只能是小写。其他混合大小的形式都不是布尔值，只是标识符。 其它类型是可以转换成布尔类型的。转换规则如下： A. 正零、负零、浮点零（0.0）、空字符串、false本身、NaN、null、undefined 被转换为假值（false）B. 其它值被转换为真值(true), 特别是对象—哪怕是空对象，也会被转换成真值trueC. 如果x是要转换成布尔类型的值，就调用Boolean(x)，你也可以写成：!!x 即可。 Number类型 JS中不管整数还是浮点数，统一归于number类型（数值类型），不像Java那样分为整形和浮点型，整形里面又分为byte,short,int,long 类型，浮点数里面又分为float,double类型，总之，JS中，数值都是number类型，可以用类型操作符typeof（x）来判断，如果返回的是一个字符串’number’, 则表明x 就是number类型。 其实，JS中的数值都是浮点数，例如有：10===10.0 //true. 需要注意的有：(1) NaN（Not a Number—非数值）是一种特殊的数值类型, typeof(NaN),得到的还是’number’ 它不应该参与任何数值类型的运算。它和自己都不相等，无论NaN == NaN, 还是NaN === NaN，得到的都是false. 任何其它的数值类型和NaN进行运算，得到的都是NaN. (2) 正无穷大表示为Infinity, 负无穷大表示为-Infinity, 它们也是特殊的number类型。 (3) 四则运算中任何一个数值类型除以0，得到Infinity, 但0/0会得到NaN, 这些也不必死记，需要时可以打开Node的命令行验证一下即可。 (4)不是所有的其它类型都可以转化为数值类型，这个需要看情况而定。转换时，如果要转换为整数，可以用parseInt()函数，如果要转换为浮点数，可以用parseFloat(), 注意没有parseDouble()函数，也可以用函数Number(),但某些值和用parseInt()/parseFloat()函数有一些区别。拿不准时，可以先用Node命令行简单测试一些，采用最合理的转换函数，避免bug. (5)最后请记住：浮点数的运算始终会有误差，能用整数时，尽量用整数。 String类型 A. JS中没有单独的字符类型，无论单个的字符还是一个字符串都是属于string类型，string类型在JS中属于原始类型，并不像其他语言例如Java中那样，字符串是对象，这是一个很显著的区别。 B. JS中的字符串可以用英文的单引号或双引号包裹起来，如’A’, “ABCD”,’Hello,world’. C. JS中的空字符串就是’’或””,单引号和双引号之间什么也没有，连空格也不能有。 D. 字符串类型有一个属性叫length,它表示这个字符串的长度（字符的个数），无论中英文字符串中，每个字符都只算一个占位，（千万别混淆：中文字符占2个字节）， 举个栗子：123456var s1='abcd';var s2="中国人民";console.log(s1.length); //4console.log(s2.length); //4 JS中的原始类型也有一些属性和方法，例如这次说的字符串类型，还有toUpperCase(),toLowerCase()方法等等。字符串类型也可以通过方括号语法，用下标来读取位于某个位置的字符，如: var s=’abcde’, 则可以用s[3]来读取下标是3的字符，即：’d’, 字符串的下标仍以0开始，和数组下标一样的开始位置，但JS中字符类型完全不同于JS中的数组类型。后者是引用类型，后面再说吧。 其他任何的类型都可以转化为字符串类型，使用函数String(x), 注意：S要大写，前面不加new运算符，x是要转化为字符串类型的一个值。至于null, undefined,函数等可以转化为字符串类型吗？当然可以，你自己用String( )函数试试看吧。 如果要判断一个变量或一个值是否为字符串类型，可以使用类型操作符typeof x, 也可以写成typeof(x), 如果得到的返回是一个字符串：’string’, 那x就是字符串类型了。此处要注意typeof(x)的写法并不是函数调用，只是这种书写看起来像函数调用罢了，别混淆了，提醒你，JS中处处有坑。 引用类型引用类型是一种用于将数据和功能组织在一起的数据结构（也常被成为类），引用类型的值（对象）是引用类型的一个实例。 但是JS中没有类的概念，因此引用类型也可以被称为对象定义，因为他们描述的是一类对象所具有的属性和方法。 对象是某个特定引用类型的实例，新对象是使用new操作符后跟一个构造函数来创建的，构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。 Object是最基本的类型，其他所有类型都继承了它的行为。在举个栗子： 1.Array类型 除了Object之外，Array算是JS最常用最常用的类型。js中的数组与其他语言的数组都是数据的有序列表，但是，数组的每一项可以保存任何类型的数据 2.Date类型 Js中用于构建日期对象的引用类型 3.RegExp类型 Js通过RegExp类型来支持正则表达式 4.Function类型 Js中的函数实际上是对象，每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。例如：123function sum(num1,num2)&#123; return num1 + num2; &#125; 这与使用函数表达式定义函数的方法几乎相差无几： 123var sum = function(num1,num2)&#123; return num1 + num2;&#125; 本文完！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[小Tips：Js和JQuery中获得当前索引值的方法]]></title>
      <url>%2F2016%2F12%2F15%2F%E5%B0%8FTips%EF%BC%9AJs%E5%92%8CJQuery%E4%B8%AD%E8%8E%B7%E5%BE%97%E5%BD%93%E5%89%8D%E7%B4%A2%E5%BC%95%E5%80%BC%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[自从用了Jquery库以后，感觉写Js代码没有那么繁琐了，之前自己用JQuery仿京东首页做了一个轮播图（就差无缝切换了…），代码量仅仅用了几十行，后来打算用原生JS写一遍的时候就悲剧了。上百行的代码量，而且JQuery用多了，自己竟然连获取原生JS中的当前索引值都不会了，还是要好好补补原生JS，基础很重要！基础很重要！基础很重要！重要的事情说三遍！所以，今天就记录下曾经踩过的坑，长个记性！在一些常见的特效里比如轮播图，下拉列表，Tab切换里都会用到循环遍历取得当前索引值并添加事件的方法，在JS中取得当前索引的方法是：123456789101112&lt;body&gt; &lt;ul id="test"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 123456789101112window.onload=function()&#123; //当页面全部加载完毕后执行 var oUl=document.getElementById("test"), //获取父元素ul oli=oUl.getElementsByTagName("li"); //获取所有的子元素li for(var i=0; i&lt;oli.length; i++)&#123; //循环遍历每一个li元素 oli[i].index=i; //重点来了（Js中获取当前索引值的方法） oli[i].onclick=function()&#123; //给当前元素添加点击事件 alert(this.index); //输出当前的索引值 &#125; &#125;&#125; 以上就是原生JS中获取当前索引的方法，其实不难就那么一行代码，虽然当时困扰了我很久….接下来就来写JQuery中的方法，这个就更简单啦！ 12345678 $(function () &#123; $("#test li").on('click', function() &#123; var me=$(this); //将当前元素存入名为me的变量里 index=me.index(); //获取当前的索引值 alert（index）； //输出当前的索引值 &#125;&#125; 看到没，JQuery代码就是这么简单，因为JQuery中提供了index() 方法，该方法返回指定元素相对于其他指定元素的索引值。 写个笔记，给自己提个醒，同样的坑不能掉下去两次了！！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[那些年我们一起踩过的坑——CSS中的命名及书写建议]]></title>
      <url>%2F2016%2F12%2F13%2F%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91%E2%80%94%E2%80%94CSS%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E5%8F%8A%E4%B9%A6%E5%86%99%E5%BB%BA%E8%AE%AE%2F</url>
      <content type="text"><![CDATA[今天来谈一谈我之前踩过的CSS坑之命名问题，相信很多跟我一样最开始学习CSS的时候都不知道怎样命名，有的起名字直接就是a，b，c，d（至少我初学的时候真的这么干过），更有甚者也会用汉语拼音来命名（例如这样：toubu，neirong，dibu等等），这些命名都是非常不好的习惯，在碰到很多复杂的页面布局时，这样命名会使自己不知所措，找一个class找很久都找不到，非常影响工（xue）作（xi）效率。经过我的多番搜寻与总结下，写了这篇博文。 为什么需要命名规范？ 合理、科学地对CSS代码命名,能够精简CSS代码,提高代码的开发效率,方便在日常工作中对网站进行维护与修改.遵循W3C所规定的语义化标准。 命名的基本标准 类名使用小写字母，以中划线/下划线分隔 1&lt;div class="header"&gt;&lt;/div&gt; id采用驼峰式命名且尽量少用 1&lt;div id="myDialog"&gt;&lt;/div&gt; 尽量不用拼音 1&lt;div id="pinyin"&gt;&lt;/div&gt; 尽量不缩写，除非一看就能懂的单词 1&lt;div class="fl"&gt;&lt;/div&gt; //fr即float: right; 禁用通配符，影响性能 CSS中的书写顺序 位置属性(position, display, float等) 大小(width, height, padding, margin) 文字系列(font系列, line-height, letter-spacing, color text-align等) 背景(background, border等) 其他(animation, transition等) 12345678.box&#123; position:relative; width:100px; height:100px; font-size:14px; text-align:center; background-color:#ccc;&#125; 常用的class命名规范 页面结构区 容器: container 页头：header 内容：content/container 页面主体：main 页尾：footer 导航：nav 侧栏：sidebar 栏目：column 页面外围控制整体佈局宽度：wrapper 左右中：left right center 导航 导航：nav 主导航：mainnav 子导航：subnav 顶导航：topnav 边导航：sidebar 左导航：leftsidebar 右导航：rightsidebar 菜单：menu 子菜单：submenu 标题: title 摘要: summary 功能区 标志：logo 广告：banner 登陆：login 登录条：loginbar 注册：register 搜索：search 功能区：shop 标题：title 加入：joinus 状态：status 按钮：btn 滚动：scroll 标籤页：tab 文章列表：list 提示信息：msg 当前的: current 小技巧：tips 图标: icon 注释：note 指南：guild 服务：service 热点：hot 新闻：news 下载：download 投票：vote 合作伙伴：partner 友情链接：link 版权：copyright CSS样式表文件命名 全局：global.css 全局样式为全站公用，为页面样式基础，页面中必须包含。 结构：layout.css 页面结构类型复杂，并且公用类型较多时使用。多用在首页级页面和产品类页面中。 私有：style.css 独立页面所使用的样式文件，页面中必须包含。 模块 module.css 产品类页面应用，将可复用类模块进行剥离后，可与其它样式配合使用。 主题 themes.css 实现换肤功能时应用。 补丁 mend.css 附图一张，加深记忆！ 简单规则 以中划线连接，如.item-img 使用两个中划线表示特殊化，如.item-img.item-img–small表示在.item-img的基础上特殊化 状态类直接使用单词，参考上面的关键词，如.active, .checked 图标以icon-为前缀（字体图标采用.icon-font.i-name方式命名）。 模块采用关键词命名，如.slide, .modal, .tips, .- tabs，特殊化采用上面两个中划线表示，如.imgslide–full, .modal–pay, .tips–up, .tabs–simple js操作的类统一加上js-前缀 不要超过四个class组合使用，如.a.b.c.d 结语好了，以上就是常用的css命名规则了，其实说白了规则就是”人如其名”，稍微懂点英语就知道只不过就是把网页中相对应的地方以英文的方式来命名，毕竟我们都是用英文来写代码的！写代码其实也可以帮助提升自己的英语水平的，一举两得，何乐而不为呢？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sublime Text3中那些常用的快捷键]]></title>
      <url>%2F2016%2F12%2F13%2FSublime-Text3%E4%B8%AD%E9%82%A3%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
      <content type="text"><![CDATA[学习前端时间也不短了，记得最开始学HTML/css的时候是通过《Head First HTML与CSS》这本书开始接触前端的，快递包裹拆开的时候整个人都懵逼了。好厚的一本书，整整700多页，对于我这种直到大学毕业了还没有好好的看过书的人来说简直是场灾难！不过幸好之前有在知乎了解到这本书虽然很厚，但是绝大部分都是以图文的形式展示出来的，所以看起来不会那么的吃力让人想睡觉。后来边看边跟着敲代码，当时的我还傻不拉几的用的windows系统自带的记事本，每天重复得敲着…等等，竟然没有很厌烦的感觉，反而乐此不疲，也许这就是在自学前端的过程中所能给我带来的最大的快乐吧，看到自己敲的代码在浏览器中呈现出来，那种感觉只有亲身经历过才会懂！ 直到我接触了sublime Text编辑器也就是今天这篇文章的重点，我就深深的爱上了他！熟练掌握各种快捷键，可以给我们日常工作中带来极大的便利，节约时间成本，把精力专心地放在项目上。那么首先我们来看看他有哪些优点！ Sublime Text：一款具有代码高亮、语法提示、自动完成且反应快速的编辑器软件，不仅具有华丽的界面，还支持插件扩展机制，用她来写代码，绝对是一种享受。相比于难于上手的Vim，浮肿沉重的Eclipse，VS，即便体积轻巧迅速启动的Editplus、Notepad++，在SublimeText面前大略显失色，无疑这款性感无比的编辑器是Coding和Writing最佳的选择，没有之一。 最常用的快捷键（以windows系统为例）命令面板 双击界面后按下Ctrl+shift+p即可调用命令面板像这样 我们可以输入Package Control安装各种插件 【首推Emmet插件】(PS:sublime text编辑器支持模糊匹配，例如输入Package Control，那么只需要输入pctl即可匹配到该命令，如下图所示) 也可以输入html，css，JavaScript等来改变要使用的语言环境 多行游标 Ctrl+H：查找替换 Ctrl+D 选词 （选中某个文本后，反复按快捷键即可选中下一个相同的文本同时编辑） Ctrl+K Ctrl+D 跳过当前选择，选择下一个 Alt+F3 选择所有与光标所在单词相同的单词 按住shift键，然后按住鼠标右键向下拖动，也可产生多行游标 第二个图为连续按了5次Ctrl+D后的结果， 也可以直接按Alt+F3！ 搜索，撤销，反撤销 Ctrl+F 搜索 （搜索当前文档中相对应的字符串，搜索到的字符串以高亮显示） Ctrl+Z 撤销 （撤销上一步的操作，可重复按键） Ctrl+Y 取消撤销（与之相反） 按下Crtl+Z后 标签页切换 Ctrl+Tab （当前窗口中的标签页切换） 切换后效果 删除整行 Ctrl+Shift+K （删除整行） 删除后效果 学以致用如何快速搭建一个HTML文档 Ctrl+N Ctrl+S 保存页面 Ctrl+shift+p 调用命令面板输入，输入HTML调用语言 编辑区输入！号 Ctrl+E Ctrl+P 输入#body回车即可跳转至body标签 Ctrl+Enter 在当前行下添加一行 ctrl+shirt+enter 在当前行上方添加一行（与之相反） (ul&gt;.item \$*10{content} ) （ &gt; 号生成子元素 ，\$ 产生序号，{ }产生内容 ） Ctrl+E Ctrl+] 增加缩进 Ctrl+[ 减小缩进 光标点击需要多选的位置 Alt+F3 全选 输入h3{}，然后Ctrl+E（注：Ctrl+E也可以用来闭合元素标签） 结语好了，以上就是在开发过程中常见的一些快捷键，希望可以通过图文并茂的方式可以更好的帮助记忆（PS：受head first 系列图书的影响…），其实这里面也有很多我自己也没用过的快捷键，以后没事儿的时候多来看看，再敲代码的时候就可以更轻松了哈哈哈，这样极大限度的摆脱鼠标的困扰，两耳不闻窗外事，一心只去敲代码！Fighting！！！]]></content>
    </entry>

    
  
  
</search>
